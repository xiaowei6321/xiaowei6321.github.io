<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-中国近代史" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.570Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/" data-id="clg5w6b96000310m9asjrf6ei" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-元素同典" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E5%85%83%E7%B4%A0%E5%90%8C%E5%85%B8/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.569Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="元素同典"><a href="#元素同典" class="headerlink" title="元素同典"></a>元素同典</h1><p>从零开始的魔法书——Novel AI入门导论</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        这是一篇指南，旨在为刚刚接触 Novel AI 的萌新快速上手 AI 作画。</p>
<p>​        本文基于无数高阶魔法师的经验与对 WEB-UI 代码进行挖掘所得成果总结而成，且包含许多个人理解和主观观点。非常欢迎各位前往元素法典交流群讨论。</p>
<p><strong>准备工作：神奇 NAI 在哪里？</strong></p>
<p><strong>Novel AI(简称 NAI)是一个线上的深度学习小说续写平台，而 NAI Diffusion 是 NAI 在 2022 年 10 月 3 日推出的基于 Stable Diffusion 算法的自动生成二次元图片的服务。</strong></p>
<h1 id="添加模型"><a href="#添加模型" class="headerlink" title="添加模型"></a>添加模型</h1><p>​        在安装完毕后，将下载的模型（以 ckpt 为后缀名的一个文件）置于 WEB-UI 根目录下方的 models 文件夹中的 Stable-diffusion 文件夹中。</p>
<p>​        可选：更改你的模型 model 文件名以添加更多模型。</p>
<p>​        可选：将 VAE 文件(文件名出现了形如 vae.pt 的部分)置于模型文件旁边，同一个文件夹内，并按照如下的正确格式更改 VAE 文件名。</p>
<p>例：若模型文件名为 model.ckpt，则改为 model.vae.pt</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="离线版如何达到官方版本的效果"><a href="#离线版如何达到官方版本的效果" class="headerlink" title="离线版如何达到官方版本的效果"></a>离线版如何达到官方版本的效果</h1><p>​        通常来讲，NAIFU 并不需要额外设定以达到官网质量，而 WEB-UI 则需要额外设定。如果缺少选项请检查 WEB-UI 是否为最新版。<strong>此为 WEB-UI 的设定：</strong></p>
<p><strong>✧ 确保正确安装 VAE 文件与 PT 文件。</strong></p>
<p>➢ VAE 文件位于 <strong>model</strong> 文件夹中，需要与模型文件<strong>（名字）.ckpt</strong> 改为同名并置于同一文件目录下方。</p>
<p>➢ PT 文件位于 <strong>modules</strong> 文件夹中，需要置于 <strong>model</strong> 文件夹中的 <strong>hypernetworks</strong> 文件夹内。</p>
<p><strong>✧ 以下在网页的 settings 中：</strong></p>
<p>➢ 将选单 <strong>Stable Diffusion</strong> 下方的 <strong>Stop At last layers of CLIP model</strong> 改为 <strong>2</strong></p>
<p>➢ 将选单 <strong>Sampler parameters</strong> 下方的 <strong>eta(noise multiplier) for ancestral samplers</strong> 改为 <strong>0.68</strong></p>
<p>➢ 选单 <strong>Sampler parameters</strong>下方的 <strong>Eta noise seed delta</strong> 设为 <strong>31337</strong></p>
<p>➢ 完成这些设定后，点击页面最上方的 <strong>Apply settings</strong> 保存。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>在深度学习中，我们使用一种称为”prompt”的方式来指导人工智能生成图像。prompt通常由一些以逗号分隔的单词、词组和短语组成，这些关键词被用来筛选和融合图像。prompt中的关键词对AI的生成过程起着关键的作用，可以通过调整关键词的顺序、使用括号和数字等方法来改变关键词的重要程度。prompt中还可以包含负面关键词，AI会尽量避免使用这些关键词来生成图像。在生成图像时，prompt就像是一个咒语，它直接决定了最终生成的图像。因此，选择合适的关键词和调整它们的顺序和权重非常重要。</p>
<p>AI对关键词的辨识顺序是从前到后，以逗号为分隔。关键词的重要程度可以用小括号和中括号调整，小括号增加为1.1倍权重，中括号减弱为0.91倍权重。括号可以多次嵌套，效果相乘。大括号在WEB-UI中没有用，官方网站上会增加1.05倍权重。可以在关键词后加上“:数字”来直接调整权重，例如(word:1.1)等同于(word)。需要注意的是，{}是NovelAI官方服务专用，仅增加1.05倍权重，使用泄露模型时不应使用此语法。更详细的信息和额外功能请参阅<a target="_blank" rel="noopener" href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Features%E3%80%82">https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Features。</a></p>
<p>在进行参数调整之前，需要先选择采样方法。不同的采样方法会影响AI生成图像的方式和速度。内置的采样方法包括 Euler A 和 Euler、LDM、DPM2 A &#x2F; DDIM等。通常来说，Euler A是速度和质量兼顾的最优选择，而DPM2 A可以在核理分配步数的情况下产生高质量的作品。DDIM和Euler则在运气较好的情况下以细腻的画风见长。如果审美疲劳了，可以尝试更换采样方法来获得新的风格。不过，不推荐使用LMS、DPM fast、LMS Karras和PLMS等采样方法，它们的生成质量通常不如其他算法。</p>
<p>迭代次数并不总是越多越好，不同的采样方法和模型对迭代次数有不同的要求。非线性迭代方法如DPM A和Euler A在一定程度的迭代次数之后，质量反而会快速下滑，而线性迭代方法如DDIM和Euler则通常需要更多的迭代次数来获得更高质量的图像。在实际使用中，需要综合考虑画布大小、目标复杂度等因素来确定迭代次数。一般来说，在512*512大小的画布和简单场景下，使用Euler A的迭代次数推荐为30到40次，使用DDIM的迭代次数推荐为25到35次。然而，最新的研究表明，更高的迭代次数可能会对生成图像产生巨大的帮助。对于更大的画布、更复杂的场景或更特殊的需求，请参考后续文献。</p>
<p>​        <strong>在最理想的情况下，一位赛博魔法师首先应当试着去理解</strong> <strong>danbooru.donmai.us</strong>，这是 NAI 的重要训练来源，也是绝大多数关键词的出处(至少覆盖 80%+)，所以在里面找到的引用数大于 2000 的 tag 直接当作 prompt 使用往往都能出效果，你甚至还能发现诸如颜文字当做 prompt 的惊人用法——而这都是可行的。但 danbooru 的访问需要跨域屏障，较为不便。</p>
<p>​        而除此之外还应该自己去收集可以用做 prompt 的材料，但是一个人上路太孤独了，拿着这把全村最好的法杖吧！</p>
<p><strong>NAI信息并联计划：<a target="_blank" rel="noopener" href="https://kdocs.cn/l/cre0TwbMkdx3">https://kdocs.cn/l/cre0TwbMkdx3</a></strong></p>
<p>​        去寻找各种各样的帖子或者指南。抽丝剥茧地借鉴前人经验，批判思考地获取其中的精华(前人可能会因错误习惯而被干扰)，也能得到不少效果很棒的 prompt。</p>
<p>​        <strong>但真正的高阶魔法师将直接应用现实生活的知识。</strong>能注意到各类 tag 的自然语言逻辑都是以现实生活中存在的单词，这是为了节省自然语言处理方面的开销并符合日常使用习惯。因此，<strong>一个英语水准较好、能运用各类生动表达、甚至理解一些场景专业术语与服装术语的魔法师可以直接应用合规的英文单词进行大段叙述描写</strong>，结果往往都将令人满意。</p>
<p>​        一位合格的赛博法师应该拥有自己的魔导书。将上述各种各样方式收集到的 prompt 与技巧整理、记录到文档或随便什么顺手的地方，都将很有帮助。</p>
<p>​        但也许真正的魔导书…并不是以赛博魔法师们想象中的那种形式存在也说不定？</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="闭目凝神，咏唱咒语"><a href="#闭目凝神，咏唱咒语" class="headerlink" title="闭目凝神，咏唱咒语"></a>闭目凝神，咏唱咒语</h1><p>​        总而言之，你查阅资料或突发奇想，得到了一些咒语。将它填入第一栏，然后再在第二栏填入随处可见的通用反咒(Negative Prompt)，点击 Generate，你的第一段咒语就完成了(笔者在此演示最简单的 <strong>冲 国</strong> <strong>特 攻</strong> 召唤术)：</p>
<p><img src="https://i0.hdslb.com/bfs/article/0bb146ca4f4d4faf9ae11631eed4befaabdad338.png@942w_273h_progressive.webp" alt="img">masterpiece, 1 girl, cute face, white hair, red eyes</p>
<p><strong>masterpiece, 1 girl, cute face, white hair, red eyes</strong></p>
<p>​        以防有人没查到——<strong>通用反咒</strong>是：</p>
<p>lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry, bad feet</p>
<p>​        如果充分理解了前文内容，并且咏唱地不那么夸张，那么第一次施法往往将无惊无险地获得成功。<strong>现在你已经脱离麻瓜范畴，拥有成为魔法学徒的潜质了，向着魔法的大门前进吧！</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="咒法二次不完备进阶"><a href="#咒法二次不完备进阶" class="headerlink" title="咒法二次不完备进阶"></a>咒法二次不完备进阶</h1><p>Once we accept our limits, we go beyond them.</p>
<p>我们至今为止的所有努力，并非全部木大。</p>
<h1 id="权与重"><a href="#权与重" class="headerlink" title="权与重"></a>权与重</h1><p>​        上文提到了关于 <strong>()、[]</strong> 的使用。以防刚把魔杖捂热的新魔法师看到这里已经忘了它们是什么意思 —— 一对小括号意味着把括起来的 prompt 权重 * 1.1，中括号则是 &#x2F; 1.1，<strong>大括号在 WEB-UI 中无调整权重作用，且会被作为文本而解析。</strong></p>
<p>​        如果因为某些需求而要大量抬升权重，可以对 prompt 进行多次括号，比如((((prompt))))，这意味着将它的权重 * 1.1 四次，也就是 1.4641。但这个写法太吓人了，数括号也很浪费时间，所以<strong>应该直接为一个 prompt 赋予权重：</strong></p>
<p><strong>(prompt:权重乘数)</strong></p>
<p>​        外层一定是小括号而非其它括号。比如 (red hair:1.5) 将直接给 red hair 赋予 * 1.5 权重，清晰简洁，便于自己回顾和他人理解，强烈推荐。</p>
<p>但务必请不要做出诸如 ((red hair:1.5)) 的奇怪写法。虽然在大多数情况下，它们的确会产生互相叠乘的正常效果，但在某些离谱的情况下则会导致<strong>权重无效</strong>。</p>
<p>​        而除了整词权重之外，也可以进行<strong>部分权重</strong>，比如如下例子：</p>
<p><strong>1 girl, white long (messy:1.2) hair, red eyes</strong></p>
<p>​        将专门对 messy 部分赋予 * 1.2 权重，其它部分不受影响。</p>
<p>​        高权重的元素会在画面中有着更大的占比或更强烈的存在感或更多的数量，是能可观地影响构图的原因之一。笔者<strong>非常不建议</strong>给出十分离谱的权重值，三个小括号也只有 1.3 左右，而一般来说 1.6 就已经很极端地占据画面了，再高至例如 2.0 只会在<strong>大多数情况</strong>下让咒语变成<strong>召 唤 古 神</strong>。</p>
<h1 id="高级咒术解析"><a href="#高级咒术解析" class="headerlink" title="高级咒术解析"></a>高级咒术解析</h1><p>​        上述的小括号、中括号与带权重小括号都属于低阶语法，比如(((prompt)))。而接下来要介绍的是更长更复杂一些的<strong>高阶语法</strong>。</p>
<p>​        <strong>高阶语法</strong>都以 <strong>[]</strong> 作为外层包括，包括<strong>分步描绘、融合描绘</strong>两种，使用高阶语法时这一对中括号不会让权重降低。高阶语法内<strong>可以嵌套</strong>低阶语法，低阶语法内也可以嵌套高阶语法——但为了交流方便不建议嵌套，高阶语法之间能否互相嵌套因具体情况不同而异，下文会做出介绍。</p>
<p>​        <strong>下****列介绍全部基于编纂本篇时推出的最新版 WEB-UI，对于 NAIFU 或较旧版 WEB-UI 可能不适用。</strong></p>
<p>首先介绍<strong>分步描绘</strong>的三种形式：</p>
<p><strong>[from:to:step]</strong></p>
<p><strong>[to:step] (不建议)</strong></p>
<p><strong>[from::step] (不建议)</strong></p>
<p>​        它的作用是让 prompt 在达到 step 之前被视为 from，在达到后视为 to。若是在对应位置没有 from 或者没有 to 则视为<strong>空</strong>。step 为大于 1 的整数时表示<strong>步数</strong>，为小于 1 的正小数时表示<strong>总步数的百分比</strong>。</p>
<p>​        比如 a girl with [green hair:red hair flower:0.2] 会在前 20% 步数被视为 a girl with green hair，在后 80% 步数被视为 a girl with red hair flower。需要注意这两个描述之间的兼容性和覆盖——在步数合适的情况下，最后形成的人物会拥有绿色头发和红色花饰，但也可能因为颜色溢出导致头发也变为红色，毕竟后 80% 没有绿色头发的限定，AI 完全可以自己理解一个随机的发色。</p>
<p>​        在最新版中，分步描绘可以嵌套，形如 [from:[to:end:step2]:step1] 的语句是可以被正确识别的。且分步描绘现在支持逗号分割，形如 [1 girl, red hair: 2 girls, white hair:0.3] 的语句也可以被正确识别。</p>
<p>​        分步描绘不特别擅长细化细节，与其分步描绘不如将细化部分直接写入持续生肖的部分。<strong>分步描绘更擅长在画面初期建立引导，大幅影响后续构图或画面生成</strong>。</p>
<p>​        需要注意的是，<strong>分步描绘具有视觉延后性</strong>——当要求 AI 在比如第 20 步开始描绘另一个不同的物体时，可能在比如第 24 步(或更晚)才能从人眼视觉上感知到另一个物体勉强出现在画面中。这是因为 AI 看待图片的方式和人眼看待图片的方式不同，<strong>在 AI 的认知里图片已经初具新物体的特性的时候，人眼可能依然看不出来</strong>。</p>
<p><strong>然后介绍融合描绘的两种形式：</strong></p>
<p><strong>[A | B]</strong></p>
<p><strong>[A:w1 | B:w2]</strong></p>
<p><strong>它们还有各自对应的可无限延长版：</strong></p>
<p><strong>[A | B | C | …]</strong></p>
<p><strong>[A:w1 | B:w2 | C:w3 | …]</strong></p>
<p>​        对于形如 [A | B] 的第一种，AI 将在第一步画 A、第二步画 B、第三步画 A…交替进行。而对于无限延长版，则变为第一步画 A、第二步画 B、第三步画 C…循环往复交替进行。</p>
<p>​        对于形如 [A:w1 | B:w2] 的第二种带权重版本，截至这句话被写下时仍由 **NAIFU 端独占(且本语法在 NAIFU 端的中括号是不必要的)**，若在 WEB-UI 端上强行使用则会导致权重数字被作为文本读取，虽然会让画面变得不同但实际上并非加权导致的效果。它的运作方式和双端都支持的 [A | B] 略有不同但效果类似，相较而言有着支持自定义比例的独特优势。</p>
<p>​        当然，WEB-UI 有着看上去类似的 [(A:w1) | (B:w2)] 语法，<strong>但它的本质其实是嵌套了一层加权</strong>。这样的加权是对于整个咒语而言而非对于中括号内的其它部分而言的，作用域不同，所以笔者不认为这和 NAIFU 端的写法完全相同。</p>
<p>​        融合描绘不可嵌套，但同样支持逗号分割。<strong>融合描绘擅长将两种事物混合为一起</strong>，比如 a [dog | frog] in black background。</p>
<p>​        这两个高阶语法有着明显的区别，<strong>尤其是在高步数下更不可以一概而论</strong>。分步描绘的 40 步 A 再加上 40 步 B 最后可能形成一个带有 B 基底特征的 A，但它会表现出明显的分立感。而融合描绘的 40 步 A 再加上 40 步 B 最后将形成简直像是化在一起的融合体。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="短元素，中元素与长元素"><a href="#短元素，中元素与长元素" class="headerlink" title="短元素，中元素与长元素"></a>短元素，中元素与长元素</h1><p>​        咏唱大致有着三种不同形式——最常见的<strong>直接咏唱</strong>、稍不常见的<strong>短句咏唱</strong>和堪称行为艺术一般的<strong>长咏唱</strong>。</p>
<p>​        假设要生成一个有着黄色头发、蓝色眼眸、白色上衣、红色裙子、黑色裤袜的全身坐姿二次元美少女，且强调服饰颜色，那么这三种咏唱分别看上去大概是这样的：</p>
<p><strong>直接咏唱(pitch 式咏唱)：</strong></p>
<p><strong>masterpiece, best quality, 1 girl, (blue eyes), (yellow hair), (white clothes), (red skirt), (black leggings), sitting, full body</strong></p>
<p><strong>短句咏唱(AND 强调咏唱)：</strong></p>
<p><strong>masterpiece, best quality, 1 girl, (blue eyes) AND (yellow hair), (white clothes) AND (red skirt) AND (black leggings), sitting, full body</strong></p>
<p><strong>长咏唱(自然语言咏唱)：</strong></p>
<p><strong>masterpiece, best quality, (1 girl with blue eyes and yellow hair wearing white clothes and red skirt with black leggings), sitting, full body</strong></p>
<p>​        注意短句咏唱的 AND 必须是三个大写字母，AND 两侧的小括号是不必要的(但建议加上)，这是一个专用语法，不过因为效果仍未明晰所以不单独介绍。此外，该语法并不能应用于所有采样方法，例如 DDIM 就不支持 AND，会导致报错。</p>
<p>​        这三种咏唱方式有什么区别呢？且看同一个种子，以至上而下的顺序分别使用它们的区别：</p>
<p><img src="https://i0.hdslb.com/bfs/article/75cd57d3e15466f2298f3b7b6d16ed9050718b91.png@942w_447h_progressive.webp" alt="img"></p>
<p><img src="https://i0.hdslb.com/bfs/article/f4ded71735216db4b318abd2eff76f0ffbd8071c.png@942w_455h_progressive.webp" alt="img"></p>
<p><img src="https://i0.hdslb.com/bfs/article/7a0b941fc27bc323568cb8b4950d45432ef30cfa.png@942w_443h_progressive.webp" alt="img"></p>
<p>​        首先，相似的构图证明了不同咏唱方法不会显著改变咒语的解析方式——毕竟就连调换各 prompt 顺序都会显著让图片改变，因此可以证明不同咏唱方法在大方向上是一致的。</p>
<p>​        不难发现，魔法师们最常用的<strong>直接咏唱</strong>总是难以很好地绑定元素颜色，有两张图片出现了明显的元素颜色错误。而<strong>短句式咏唱</strong>虽仍有两张图片出现了明显元素颜色错误，但是错误的视觉占比变小了。<strong>长咏唱没有出现明显元素颜色错误</strong>，很好地处理了各个颜色与元素的绑定关系。</p>
<p>​        这就是最早探索元素绑定的<strong>“蓝黄白红黑”试验</strong>。试验内容仅限简单场景，但更多后续探究证明了此结论在复杂画面中也一定程度上适用——虽然效果相较于简单场景而言稍不明显，但在提升稳定性方面有所帮助。<strong>长咏唱能加强主体与元素之间的绑定关系、提高不同元素之间的区分度</strong>，在有明确绑定需求的情况下优于 pitch 式咏唱；<strong>直接咏唱则更擅长处理关系要求不强的情景</strong>，往往能营造更多样化的场面；短句式咏唱介于两者之间。</p>
<p>​        长咏唱的关键在于<strong>也几乎必须</strong>要用一个小括号包括整个句子，以略微提升权重(权重略大于 1.0 的情况下表现最佳，但太大就有点过头了)，否则无法和直接咏唱拉开差距。</p>
<p>​        这即为“<strong>元素污染</strong>”这一概念的根本原因和初级建议应对方法。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="我的法杖不听话了？"><a href="#我的法杖不听话了？" class="headerlink" title="我的法杖不听话了？"></a>我的法杖不听话了？</h1><p>​        有的时候会返回黑色图片，俗称<strong>黑图</strong>。</p>
<p>​        黑图最简单直接的原因是<strong>显存爆了</strong>，查看后台是否出现类似于 CUDA out of memory，如果出现那就真的是显存爆了，提高配置或降低画布大小吧。</p>
<p>​        <strong>但更大的可能是显存没爆。</strong>显存没爆要分三种情况：</p>
<p>​        1.因为内容不够的模型有着明显的局限性，当一段咒语太过精简、画布还太大，这会导致自由度太大，<strong>超出模型理解范围</strong>。比如在 2k*2k 那么大的画布却只要生成一个简单背景&#x2F;无场景&#x2F;无细节指定单人像(masterpiece, 1 girl)，那么模型必然将因无法理解而黑图。</p>
<p>虽然现在常见的 4g 模型与 7g 模型能很好地满足日常使用，但是对于某些极端情况依然是“不够”的。<strong>此时建议调整咒语，根据画布大小酌情扩增</strong>。</p>
<p>​        2.当一段咒语太过繁杂、画布还太小。这种情况是上一种的反向，但原因也是超出模型理解范围。解决方法同样是建议调整咒语，根据画布大小<strong>酌情精简</strong>。</p>
<p>​        3.当一段咒语的结构出现明显问题。<strong>请参照后续章节进行解决</strong>。</p>
<p>​        不过在更多时候，法杖不听话的表现并不是黑图。例如在比 2k<em>2k 稍小一些的 1.2k</em>1.2k 画布中，可能会出现如下情况：</p>
<p><img src="https://i0.hdslb.com/bfs/article/e786b808d32e992e006ab2c35268b33dc9cfab2a.png@942w_942h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, 1 girl, white hair, red eyes</strong></p>
<p>​        明明要求 1 girl，但为什么它生成了 <strong>2 个</strong>二次元美少女？</p>
<p>​        现在我们回想刚才的黑图情况。AI 完全无法理解咒语的最大原因是自由度过高，而缩减画布可以降低自由度。但对于这段如此简单的咒语而言，将画布缩减为 1.2k*1.2k 依然显得有些<strong>太过自由</strong>了。画完一个美少女之后该怎样填充剩下的画布呢？AI 可能会使用纯色背景、构筑一个简单的空间，但它更可能会做的事情是——<strong>把已有的东西重复再画一份</strong>。(如果往深处讲，那就要涉及到目前 SD 训练模型时的方法导致目前 AI 的局限性。SD 训出来的模型其实并不理解数字，对于 AI 而言 1 girl 和 2 girls 并不互相冲突，再加上懂得都懂的那些训练集里的各种共有 tag 会给它们一定程度上的联系，所以在无物可画但必须要填充画面时倾向于多画一份。)</p>
<p>​        所以要解决这个问题也不难。既然它自由度过高，那么加长咒语让它有更多可画之物，<strong>限制它的自由度即可</strong>。</p>
<p><img src="https://i0.hdslb.com/bfs/article/d709a84f85f07ded362a810cb311ddf34e029036.png@942w_942h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, 1 girl, solo, white hair, red eyes, black gown, in room, chair, vase, red carpet</strong></p>
<p>​        <strong>High res. fix 也能解决此类问题，但它是利用先在小分辨率渲染再放大到目标分辨率的方法。最符合字面意义的做法还是直接从根源下手。这即为“元素溢出”这一概念的根本原因和初级建议应对方法。</strong></p>
<p>​        最后是一些碎碎念…</p>
<p>​        不必为每个 prompt 都加上过多小括号来提高权重，如果你发现你真的需要给绝大多数元素都加上四五个小括号才能让你想要的东西确保出现，那么更建议酌情普遍删掉一些括号，改为拉高 CFG Scale ，比如 12 甚至 14。在极端情况下，给单个 prompt 加上过多权重，可能会导致自由度过小而黑图。</p>
<p>​        除非明确清楚重复 prompt 意味着什么、且有强烈的对应需求，否则<strong>不建议重复输入 prompt</strong>。重复输入 prompt 的语义相当复杂，不在入门范畴内。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="不必保持如此神秘的敬畏…"><a href="#不必保持如此神秘的敬畏…" class="headerlink" title="不必保持如此神秘的敬畏…"></a>不必保持如此神秘的敬畏…</h1><p>​            既知が世界だ，未知はいらない！</p>
<p>​            未知的，不需要。已知的，才是世界！</p>
<h1 id="魔法的极致或许是科学"><a href="#魔法的极致或许是科学" class="headerlink" title="魔法的极致或许是科学"></a>魔法的极致或许是科学</h1><p>​        了解各类 prompt 的存在并不意味着就掌握了一切，摘抄别人的 prompt 囫囵吞枣地使用也不是上乘。如果想要让 AI 创作出更佳的作品，那么还需要深入了解各个 prompt 到底有着何等作用，以备日后使用。<strong>各个 prompt 之间的互相影响如同魔法反应一样，大多数情况下并不像是仅仅简单字面意义上的互相叠加那样简单</strong>。</p>
<p>​        举个例子，比如 an extremely delicate and beautiful girl 其实就会导致不少风格化表达被覆盖；而 light 用作颜色在很多情况下不是指淡而是发光，甚至在某些稀有的组合里还专指黄光；让一个角色手上握着武器可能不仅仅要 holding weapon 还需要加上 weapon 本身，诸如此类。</p>
<p>​        <strong>因此，各类科学分析方法甚至是研究方法都是有必要的。</strong>上文介绍的<strong>“蓝黄白红黑”试验</strong> 就是它的体现之一。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="元素魔法？定性定量分析法！"><a href="#元素魔法？定性定量分析法！" class="headerlink" title="元素魔法？定性定量分析法！"></a>元素魔法？定性定量分析法！</h1><p><strong>授人与鱼不如授人与渔。</strong></p>
<p>​        对于同一组 prompt 而言，魔法师们常以良品率作为无意识的定性分析的结果，但对于其它方面也可以进行分析，比如<strong>单个 prompt</strong>。</p>
<p>​        SD 模型基于种子(seed)来进行生成，<strong>如果条件(prompt)和种子(seed)都相同，则生成的图必然相同。利用这个特性可以对不同的 prompt 进行定定性分析</strong>，填写一个种子，固定绝大多数 prompt，然后调整&#x2F;添加想要测试的那一个 prompt，来确定它的作用、效果。</p>
<p>​        想知道一个 prompt 是否真的有意义吗？是否真的有传言所说的种种作用？它和某些组合的搭配真的很好吗？来定性分析它吧。</p>
<p><img src="https://i0.hdslb.com/bfs/article/1e316a7358b8e149cd1d5e786e88127529f4f286.png@942w_308h_progressive.webp" alt="img"></p>
<p>​        介绍如何使用 Script 中的 X&#x2F;Y plot(X&#x2F;Y 坐标图)来辅助分析。</p>
<p><img src="https://i0.hdslb.com/bfs/article/d4a43d99de59dc5e285fdb17aed22f88f2623104.png@647w_173h_progressive.webp" alt="img"></p>
<p>​        在输入框输入等待被替换的 prompt，然后使用 X&#x2F;Y 的 Prompt S&#x2F;R 功能。</p>
<p><img src="https://i0.hdslb.com/bfs/article/b0a2d5f5c91450d57ca6df443874ad901a46a45e.png@942w_575h_progressive.webp" alt="img"></p>
<p>​        在右侧的 X values 中进行填写。<strong>第一个 prompt 是被替换位点</strong>，而后面的则是希望替换为的 prompt，最后生成即可得到结果。</p>
<p><img src="https://i0.hdslb.com/bfs/article/8c231dcd6fa480f076dc103878d32e0852a09033.png@942w_297h_progressive.webp" alt="img"></p>
<p>​        除此之外还可以尝试其它不是 Prompt S&#x2F;R 的选项，比如用 Seed 比较不同种子，用 Step 比较不同步数，诸如此类。更深一步则是进行多组分析，以及通过排列组合或其它统计方法来确定多个要素之间的作用等。</p>
<p>​        如果不做定性&#x2F;定量分析，那么可能将持续沉浸在知其然不知其所以然的程度，也可能仅满足于妙手偶得而产生相对片面的理解。</p>
<p>​        <strong>始终记得赛博魔法的本质是科学。</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="力大砖飞，超级步数出奇迹"><a href="#力大砖飞，超级步数出奇迹" class="headerlink" title="力大砖飞，超级步数出奇迹"></a>力大砖飞，超级步数出奇迹</h1><p>​        在上文基础部分，笔者推荐在简单情况下将步数设为不算高的数值，因为在简单画面的情况下步数过高也似乎没有什么好细化的。</p>
<p>​        <strong>但要是在一个细节稍复杂的场景里把步数做得很高很高那么会发生什么？</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/993edd112de15dac8f6ff9c639408f3bc639c8d5.png@942w_188h_progressive.webp" alt="img"></p>
<p><strong>(masterpiece), best quality, 1 girl, red eyes, white hair, white gown, forest, blue sky, cloud, sun, sunlight</strong></p>
<p>​        不难发现画面的确变得精细了。空中的云变得更真实，人物背景从简单的树林过度到有层次的树林再变成土丘上的树林。当然，最显著的还是人物体态的变化——虽然手部的举起与放下之间似乎无法分辨出什么规律，但似乎也有着被进一步细化的情况。总得来说，简略与详细都有独到之处，是萝卜白菜各有所爱的程度，也难怪大多数情况下认为步数过高没有特别的收益…</p>
<p>​        <strong>等等。我们刚刚是不是提到了手？</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/27dab041e515bf91b695246d11ff42e423100311.png@942w_399h_progressive.webp" alt="img"></p>
<p><strong>(masterpiece), best quality, 1 girl, red eyes, white hair, white gown, hands</strong></p>
<p>​        人物整体在 20 步就已经奠定完毕，后续步数没有显著改动，但是手却不一样。20 步的手就是一团错位的麻花，40 步虽然显得扭曲但是已经能和胳膊接上，60 步除了部分手指以外都做得不错，80 步更是在此基础上进一步降低了融化程度。虽然 80 步的手也没有达到理想中的效果，但是不难发现<strong>高步数下，人物手部的表现有着明显提升</strong>。</p>
<p>​        这个结论在绝大多数情况都适用——如果想要特别细化手部表现力，那么请忽略上述步数建议，将步数拉到 80 甚至更高。而进一步推论是，<strong>高步数在合适 prompt 的引导下，对于大多数细小、解构复杂的区块都效果拔群</strong>，只是对于大块非复杂场景方面的营造存在显著边际效应。当然，如果场景本就复杂还希望细化诸如手部的位置，那就请 120 起步吧。</p>
<p>​        <strong>可是，最新的研究表明：就算想要修手，也未必要如此高的步数？</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-9"><a href="#-9" class="headerlink" title=""></a></h1><h1 id="魔法公式入门"><a href="#魔法公式入门" class="headerlink" title="魔法公式入门"></a>魔法公式入门</h1><p>​        <strong>首先，prompt 并不可以随意堆积，不是越多越好。</strong></p>
<p>​        模型读取 promot 有着明确的先后顺序，这体现为理解顺序的不同。比如又一个著名的<strong>“少女与壶”****试验</strong>所展示的：</p>
<p><img src="https://i0.hdslb.com/bfs/article/769baac92b77c88e1bb04a4fd024c9b88d35c098.png@942w_471h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, 1 girl, red eyes, white hair, blue pot</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4fbb80dc279e89f6585648f069549fb291011ef5.png@942w_471h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, blue pot, 1 girl, red eyes, white hair</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/a811ec9214d190d17c6c4b441980a20e7fccaf36.png@942w_471h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, blue pot, ((1 girl)), red eyes, white hair</strong></p>
<p>​        在种子相同且其它参数也完全相同的情况下，仅仅是颠倒了 1 girl 与 blue pot 的顺序，<strong>构图</strong>就产生了极大的变化。</p>
<p>​        不难发现，1 girl <strong>在前</strong>的情况下，<strong>画面围绕着人物展开</strong>，blue pot 体现为环绕着人物的场景物件。而 blue pot <strong>在前</strong>的情况下，<strong>画面围绕着盆展开</strong>，人物反而退出了画面中心，甚至哪怕加大 1 girl 权重也无法让人物比盆在画面中更重要。</p>
<p>​        这其中的原理不适合在入门魔导书中详细解释，但可以提供启发 —— <strong>prompt 的顺序将影响画面的组织方式</strong>，越靠前的 prompt 对构图的影响越“重”，而越靠后的则往往会成为靠前 prompt 的点缀或附加物。顺序对于构图的影响在大多数情况下甚至大于权重的影响。</p>
<p>​        虽然这个试验本身只涉及了一个场景，但在更多后续探究与复杂场景构筑中都证明了它具备的有效性。<strong>不过它也非绝对保障，在少数情况或极其复杂的场景中，叠加式构图有可能因为其它尚未在此介绍的原因而失效</strong>，但总得来说它能增强稳定性。</p>
<p>​        <strong>这就是用于替代“顺序权重论”的“顺序叠加论”</strong>。而进一步可以延伸出构筑合理咒语的灵感。将最着重体现的元素靠前摆放，然后是它的细节，再将抽象、全局化、影响极度强烈的 prompt 写在靠后处，例如场景和画风滤镜。</p>
<p>​        所以我们开始构筑一套简单的人像召唤魔法顺序公式。将上述经验总结为：</p>
<p>​        <strong>前缀+需要重点突出的物件&#x2F;背景+人+人物特征&#x2F;元素+人物动态+服饰整体+服饰细节元素+大背景+背景元素+光照效果+画风滤镜+微小辅助元素+后缀</strong></p>
<p>​        这是对“标准三段术式”结合而得出的<strong>“标准顺序公式”</strong>，包括了“标准三段术式”，是它的进一步发展。不难发现这种公式的构成符合上述理论，每一个相对靠后的部分都是对相对靠前的部分的补充，模块化明确，有着极强的可维护性，且<strong>最重要的特性是易于理解与交流</strong>。</p>
<p>​        上文可能过于抽象，因此强烈推荐参考标准三段术式的细节解析，可以互相印证互相补充：</p>
<p><strong>标准三段术式及绚丽术入门与解析v2</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.qq.com/doc/DSHBGRmRUUURjVmNM">https://docs.qq.com/doc/DSHBGRmRUUURjVmNM</a></strong></p>
<p>​        <strong>熟悉或熟练这种公式能令一个刚接触 AI 的新手更顺畅地表达自己想要表达的画面，要是悟性够好生活经验够丰富则还可以触及高表现力</strong>。比如它可以生成：</p>
<p>​        一个二次元美少女+收束的长发&#x2F;飘散的长发&#x2F;占满屏幕的长发+复杂的哥特服饰&#x2F;长裙&#x2F;旗袍&#x2F;等一系列可以上花纹或褶皱的衣服+一个帅气或优雅的动作&#x2F;看淡生死面无表情+复杂的建筑物或自然风景或宇宙空间或阴暗背景+强大或温柔的光照+魔法特效+大量星点&#x2F;鲜花&#x2F;粒子效果&#x2F;填充物+尝试营造cg感的9:16画布&#x2F;1:2画布+画风滤镜…</p>
<p>​        等等，诸如此类能直接进入元素法典早期卷的作品(从入门到入典)。在有经验验证的理论基础上进行自由创作，往往能取得令人感到满意的结果。</p>
<p>​        不过标准顺序公式也有许多缺陷，它对于某些独特的情况可能不适用，即使作为特解也一定会在将来被更先进的经验所替代。<strong>实际运用过程中应当根据要求进行灵活调整</strong>，比如根据实际使用情况简化&#x2F;删去某些环节，或根据实际要求进一步增加某些环节，甚至为了某些特殊效果而部分违反公式顺序。但它的“叠加式”思路，与其背后所蕴含的分析思想才是精髓。</p>
<p>​        <strong>笔者坚信赛博魔法的终极形态是基于顺序和关系的模块化发展、本质是对于经验进行总结所得出的具体规律，是可以使用科学方式进行一定程度上的研究的</strong>。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-10"><a href="#-10" class="headerlink" title=""></a></h1><h1 id="-11"><a href="#-11" class="headerlink" title=""></a></h1><h1 id="向着魔导科学的最根源"><a href="#向着魔导科学的最根源" class="headerlink" title="向着魔导科学的最根源"></a>向着魔导科学的最根源</h1><p>​        或许…(划掉)…才是这个世界的唯一神，所有人都将是它的奴仆。</p>
<h1 id="重新解析咒语构成"><a href="#重新解析咒语构成" class="headerlink" title="重新解析咒语构成"></a>重新解析咒语构成</h1><p>​        上文介绍了标准顺序公式，但能不能再给力一点？</p>
<p>​        <strong>当然能！</strong></p>
<p>​        我们再仔细想想上文的标准顺序公式是怎样的思路——浓缩到极致，就是引导质量、突出物、人、细节、背景、修饰。不错，但当初为什么要把人和突出物分开？为什么修饰一定要在后方？背景又是怎样界定的？</p>
<p>​        如果读者已经尝试过许多此标准顺序公式，那还能继续问出——为什么有时候画面没有严格按照顺序构图？为什么有时候修饰的效果不够拔群？</p>
<p>​        无数个疑问都迫切指向了新的思考方式。<strong>现在我们将一切都抽象为“物”</strong>。人是一个物，人身上的一些小挂饰也是一个物(无论这个挂饰的数量是多少)，背景里的建筑也是一个物，诸如此类。<strong>物！</strong></p>
<p>​        每个物都有能力成为主要描绘对象。如果是人，那么可以是人的立绘或特写，如果是挂饰，可以是它的展览模样，甚至背景大建筑也可以成为全景的视觉中心。<strong>而当画面中存在多个物时，将不可避免地分为主要的物和次要的物</strong>，次要的物还可以有相对它而言更次要的物。这和此前的基础顺序公式不同，因为基础顺序公式默认一切事物都可以互相叠加——<strong>但事实证明不是那样。</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-12"><a href="#-12" class="headerlink" title=""></a></h1><h1 id="无法被叠加的次要物"><a href="#无法被叠加的次要物" class="headerlink" title="无法被叠加的次要物"></a>无法被叠加的次要物</h1><p>​        不难注意到有些“物”像是无视了叠加式构图原则那样，除非权重高到让它占满屏幕，否则往往只能作为配角存在、难以被其它“物”作为叠的目标。这些“物”天生有着被视作次要的特征，和许多能做主能做次的物并不相同。</p>
<p>​        那么什么因素决定哪些物更倾向于被视为次要呢？<strong>终极答案是生活经验</strong>。</p>
<p>​        (除非特别声明，否则以下对比均默认来自于同一 seed)</p>
<p>​        当 1 girl 和 earing 简单结合时，无论两者谁先谁后，最后都会变成“一个二次元美少女带着耳环”的样子，不会在简短描述下就轻易地出现诸如“美少女向前抬手捧着耳环、耳环在镜头前是一个特写、美少女的身体被景深虚化”的情况。因为在我们的生活常识中，大多数这两个“物”结合的情况都是前者，后者在作品描绘里出现的情况极少，因而这两者<strong>即使是顺序调换也只是让美少女是否摆出展示耳环的姿势，无法轻易地切换主次</strong>(继续深讲就到训练集的部分了，虽然它的本质是训练集与LatentDiffusion对于自然语言的处理，但考虑到大多数组成训练集的作品都取自于生活经验 &#x2F; 常见创作想象，且自然语言处理本就是努力拟合生活经验的过程，所以实际上并无明显不同，因而在此打住话题)</p>
<p><img src="https://i0.hdslb.com/bfs/article/e6914312e91f0cc020a2d7605b53897c1be53159.png@942w_471h_progressive.webp" alt="img"></p>
<p><strong>masterpiece, 1 girl, earing</strong></p>
<p><strong>masterpiece, earing, 1 girl</strong></p>
<p>​        但当 1 girl 和 lake 结合就不一样了。lake 虽然往往被当做背景，但它完全可以成为风景画的主要描述对象，所以在除去刻意设置了镜头的情况下——<strong>当 1 girl 在前</strong>，重要的“物”为人物，所以画面往往会让人物占据主要部分(包括人物全身像站在景物前、人物半身像加远景，甚至人物直接泡水)，<strong>而当 lake 在前</strong>，重要的“物”为湖，湖在我们的生活经验中的确可以成为主要对象，因此画面往往会让人物显得更小、更融入风景或距离视角更远。</p>
<p><strong>masterpiece, 1 girl, lake</strong></p>
<p><strong>masterpiece, lake, 1 girl</strong></p>
<p>​        当“物”的数量大于 2，这个规律也依然适用， 1 girl 和 lake 和 bike 以及 earing 之间的排列组合符合上述情况：earing 总是忽略顺序作为次要装饰在人物的耳边，人物、湖、自行车则根据顺序不同而有不同的强调位置，其中 bike 即使靠后也往往不会过度隐入 lake。</p>
<p><strong>masterpiece, 1 girl, lake, bike, earing</strong></p>
<p>​        但更重要的是，<strong>运用得当的次要物可以一定程度上打破叠加式顺序结构</strong>。因为 AI 会努力把所有咒语中的内容都画出来，而次要物们恰好大多数是小块结构。在如第二张图一样的远景中画出让 earing 被 AI 认为是不可能的，所以它会强行打破叠加式结构，让人物被聚焦到画面相对更前的位置，作为对次要物的强调。</p>
<p><strong>masterpiece, lake, earing, bike, 1 girl</strong></p>
<p>​        lake 在前，但是效果更接近于想象中 lake 在后的情况。在这种强调情况下，甚至 1 girl 在前也无法让它显著地再次提高强调。</p>
<p><strong>masterpiece, lake, 1 girl, earing, bike</strong></p>
<p>​        无论怎么说，它从原理和实际表现效果都和人有(一点点)相似之处。虽然 AI 绘画看上去是一步成型，但它一定程度上还是会根据“物”与“物”之间的关系来决定构图，并结合场景与反常情况无视部分顺序。</p>
<p>​        所以我们先总结出某种通用顺序公式的<strong>雏形</strong>：</p>
<p>​        <strong>前缀+“物1”+“物1的各种次要物”+“物2”+“物2的各种次要物”+“物3”+“物3各种次要物”+…</strong></p>
<p>​        其中“物1、2、3…”是逻辑上能轻易成为主要聚焦点、占据大画面比率的物件，“次要物”则反之。物按照希望的构图主次顺序排列，而将次要物顺序放在其附着对象之后是为了结构简洁明确，也是为了避免超出预期的反常强调。</p>
<p>​        <strong>不难发现它是对基础顺序公式的进一步抽象化，但有一些细节处理不同。</strong></p>
<h1 id="-13"><a href="#-13" class="headerlink" title=""></a></h1><p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-14"><a href="#-14" class="headerlink" title=""></a></h1><h1 id="远近、光影与其它令人惊讶的东西"><a href="#远近、光影与其它令人惊讶的东西" class="headerlink" title="远近、光影与其它令人惊讶的东西"></a>远近、光影与其它令人惊讶的东西</h1><p>​        雏形去除了突出物体、人像和背景的地位差别，并解释了某些“物”难以参与到顺序公式的叠加式构成的原因。但它少了很多关键要素，比如颜色和形状怎么算？姿势和动作怎么算？光照、镜头、画风直接放在最后面真的是负责任的做法吗？还有用于给整个画面染色或营造氛围的引导词又该如何？</p>
<p>​        继续提取。颜色、形状和其它形容词若是用于形容单个物件而不希望让它污染其它元素，则往往与物件本身合并，例如红色衣物通常会用 red clothes 而不是 clothes, red。同理圆形桌子、漂浮的缎带、绿色的飞行叶片也都类似，所以物的特征可以归入“物”环节中，与标准顺序公式的处理相同。</p>
<p>​        然后我们为画面引入镜头要素。指定镜头能极其显著地提高画面质量，比如全景镜头往往能很好地展示风景，4 个词轻松爆杀大量早期堆景物的风景画。</p>
<p>​        (除非特别声明，否则以下对比均默认来自于同一 seed)</p>
<p><strong>masterpiece, lake, panorama, 1 girl</strong></p>
<p>​        一切看似都是那么合理与自然，直到事情来到了复合镜头。</p>
<p><strong>masterpiece, lake, panorama, 1 girl, close up</strong></p>
<p>​        没人知道 close up 干啥去了，反正笔者不知道。现在我们同咒语换个种子。</p>
<p>​        这是 close 了个什么？又 panarama 了个什么？</p>
<p>​        这段咒语本来的意图是“在湖全景的旁边加入一个二次元美少女的特写”，但效果令人难蚌，而其实上面两种构图就是这段咒语能形成的全部构图了。</p>
<p>​        其实仔细想想不难发现，AI 的确在努力按叠加顺序与镜头走，不过 lake 在前 1 girl 在后让它希望以湖作为主要元素，这就导致<strong>“本就含有顺序属性”的镜头</strong>被丢失或以令人感到匪夷所思(但对这套逻辑来说合情合理)的形式展现。</p>
<p>调换镜头的顺序是无效的，生成的图片要么让人融入景物、要么在画面前端但大多数情况下无法达到“特写”的程度。</p>
<p><strong>masterpiece, 1 girl, panorama, lake, close up</strong></p>
<p>​        但调换“物”的顺序有效，一定程度上地。</p>
<p><strong>masterpiece, 1 girl, close up, lake, panorama</strong></p>
<p>​        所以可以初步得出结论，镜头的插入位点未必一定要是在咒语的最末端，尤其是需要复合镜头的情况。它可以插入在一切物之前、所意图修饰的那个屋之后、一切物之后，分别用于大幅影响整个画面、主要影响单个物+轻量地影响整个画面、轻量地影响整个画面。而光照也同理类似。</p>
<p>​        但这说到底也是<strong>相对情况</strong>。上述测试采用了相同的种子，表明了一种写法相对于另一种写法在同种子的情况下更倾向于预期，<strong>不代表最终成品在绝对意义上总是符合预期</strong>。换句话说，这样能提高稳定度，但若需要彻底稳定则不能只寄希望于镜头控制，还应该合理安排其它元素。</p>
<p>​        close up、close shot、medium view、panorama 这几个镜头控制十分好用，但它们在不同的位点影响力不同。光照也类似，在不同位点的 backlight 和 rembrandt lighting 对于人物或全画面的立体感影响也并不一样。</p>
<p><strong>masterpiece, 1 girl, medium shot, backlight, lake, panorama, night, moon</strong></p>
<p>​        可见在按顺序构图的情况下，根据需求选择镜头与光照对于画面质感与效果的提升有极大帮助。而更重要的是，通用顺序公式的<strong>雏形</strong>可以进化一次了：</p>
<p>​        <strong>前缀+前置镜头效果+前置光照效果+[带描述的物x+物x的各种次要物+镜头效果和光照(如果必要)]*X+全局光照效果+全局镜头效果</strong></p>
<p>​        <strong>镜头效果和光照效果勿过频</strong>，因为 AI 还不能很好地处理多个物体分别在不同镜头下的情况，而光照更是往往会影响图片的大部分区域。紧挨着的每个镜头与光照的正反顺序影响不大，但笔者个人感觉上述顺序的质量更佳，实际上可酌情调整。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-15"><a href="#-15" class="headerlink" title=""></a></h1><h1 id="通用顺序公式"><a href="#通用顺序公式" class="headerlink" title="通用顺序公式"></a>通用顺序公式</h1><p>​        最后一块拼图是画风。</p>
<p>​        (除非特别声明，否则以下对比均默认来自于同一 seed)</p>
<p><strong>masterpiece, 1 girl, sketch</strong></p>
<p>​        先不去管因为画布过大导致的人像重复。总得来说，画风放在 1 girl 的前或后没有显著差别，似乎随便找个位点把画风词一插就完事了。在目前的入门范畴内，可以认为插入位点不同也没有特别显著地让 sketch 感有明显强弱变化，构图差异是可以理解或可以接受的。而让多个风格各自独立地共存并不在入门范畴。</p>
<p>​        但除了 sketch、oil painting 此类明确表示画风的 prompt 之外，还存在着诸如 wallpaper、illustration、anime 等看似一点都不画风但又难以简单被归类为质量补正的东西。在许多魔法师眼中， <strong>wallpape****r</strong> 等要素应该和 <strong>masterpiece</strong> 算在一起作为前缀，可实际上它们往往能对画面产生质变，混合使用还可能产生可怕的化学反应。</p>
<p><strong>masterpiece, 1 girl, yellow hair, blue eyes, lake</strong></p>
<p><strong>masterpiece, wallpaper, 1 girl, yellow hair, blue eyes, lake</strong></p>
<p><strong>masterpiece, illustration, 1 girl, yellow hair, blue eyes, lake</strong></p>
<p>​        更何况还有许多未在此列出的东西，比如 highly detailed 本就会让画面部分地偏向于厚涂甚至油画(ultra-detailed 甚至不如它有用，是个以讹传讹；板：我不想背这个锅但确实我有频繁使用这个tag )，anime 会让画面线条偏向粗糙手绘但又不像 sketch 那样痕迹明显。</p>
<p>​        很难绷。而且硬要追根究底下去的话，masterpiece 和 best quality 本质上也是一定因素是通过改变质感表现来提高画质的，再深想下去会让问题变成“到底怎样算美”。所以干脆根据使用率来做区分，将 masterpiece&#x2F;best quality 之外的一切“类质量前缀”算为画风引导。</p>
<p>​        所以我们得到了最后的调整版：</p>
<p>​        <strong>质量前缀+前置画风引导+前置镜头效果+前置光照效果+[带描述的物x+物x的各种次要物+镜头效果和光照]*X+全局光照效果+全局镜头效果+画风滤镜</strong></p>
<p>​        其中，物x的排序按预期构图重要顺序排列，次要物的排序按颜色相近顺序整理排列。例外在于存在微小的人物的次要物时，景物的顺序主要在景物之间起效。所有镜头、光照和画风均为可选项，且为避免反应过于复杂考虑建议各不超过 3 种。</p>
<p>​        <strong>这就是标志着真正入门的，通用顺序公式</strong>。通用顺序公式结合了标准顺序公式的全部内容，并体现了对于“物”之间关系的进一步思考，也将镜头处理纳入公式内。将顺序公式与前文提及的长短咏唱等技巧相结合，熟练运用，是一个真正赛博魔法师的必备素养。</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-16"><a href="#-16" class="headerlink" title=""></a></h1><h1 id="是结束也是开始"><a href="#是结束也是开始" class="headerlink" title="是结束也是开始"></a>是结束也是开始</h1><p>​        <strong>通用顺序公式显然也不是一切的答案</strong>，毕竟它标志的是入门而不是大成——本魔导书所详细解释的一切内容都是入门级内容。它更像是对于如何理解 AI 运作方式的思考帮助，而不是能无脑解决所有难题的万用工具，实际操作依然需要更多经验总结来灵活变通。</p>
<p>那么该如何进阶呢？(这句话有点太干涸了，等待板板润色)</p>
<p>这里不作过多展开，仅留下一些思考线索：</p>
<p>长咏唱能绑定元素，但为什么它的不稳定度反而比其它咏唱方式还高？</p>
<p>分步绘画的画面在分步前后之间有什么关系？</p>
<p>为什么分布绘画能一定程度上“识别”从何处替换物？</p>
<p>每 1 step 在不同完成度下对于 AI 而言到底意味着多大的变化？</p>
<p>不同种子同咒语的镜头为何在绝对意义上频频产生混乱？</p>
<p>叠加式构图中“叠加”的根源是什么？</p>
<p>不同 prompt 是如何产生互相联想关系与“建议前置”关系的？</p>
<p>当一个 prompt 含有多个元素意义时，AI 会如何对颜色、形状等分别处理？</p>
<p>为什么超高步数可以修手？为什么修手一定要那么高的步数？</p>
<p>权重到底意味着什么？数量？画面占比？结构复杂度？</p>
<p>重复输入 prompt 到底意味着什么？</p>
<p>单个长单词也会被拆分吗？</p>
<p>……</p>
<p><strong>魔法的殿堂恢宏而瑰丽，无尽的回廊里昭示着无限的可能性。</strong></p>
<p><strong>朝更远处进发吧。</strong></p>
<h1 id="先等一等…"><a href="#先等一等…" class="headerlink" title="先等一等…"></a>先等一等…</h1><p>还记得最开始笔者提到过…</p>
<p>prompt 可以识别一些特殊符号吗？</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="该死的流汗黄豆！你不要过来啊！"><a href="#该死的流汗黄豆！你不要过来啊！" class="headerlink" title="该死的流汗黄豆！你不要过来啊！"></a>该死的流汗黄豆！你不要过来啊！</h1><p><strong>魔法世界的集大成者居然是流汗黄豆表情，怎么会这样 —— 难道我们最终的归宿就是被流汗黄豆所支配吗？！</strong></p>
<h1 id="♿-认-知-革-命-♿"><a href="#♿-认-知-革-命-♿" class="headerlink" title="♿ 认 知 革 命 ♿"></a>♿ 认 知 革 命 ♿</h1><p>​        如上文所述。</p>
<p>​        还记得最开始笔者提到过 prompt 可以识别一些特殊符号吗？说到特殊符号，赛博魔法师们会想到什么？流汗黄豆？</p>
<p>​        还真就是<strong>流汗黄豆</strong>。  😅 (这里不准出现流汗黄豆啊kora!</p>
<p>​        准确来说，是以流汗黄豆为代表的各类 emoji 字符。</p>
<p>​        先直接说结论。<strong>Emoji 可以直接作为 prompt 输入</strong>，作为 prompt 自然兼容上文提及的一切低阶语法高阶语法，而且单词效果强到可怕。</p>
<p>​        笔者特地去翻了翻 SD 框架的处理部分，发现 emoji 符号的确没有被转义为英文，而是原原本本地就以字符形式被处理。笔者不知道到底是什么人以什么样的精神状态将 emoji 作为 tag 进行训练，但总之这件事情就这么发生了，emoji 它就是可以当作 prompt 用。</p>
<p>​        那么为什么 emoji 如此强大呢？这里解释理由：</p>
<p>​        Emoji 是<strong>单个</strong>字符，可以<strong>无视</strong> SD 框架对它识别时的一切拆分尝试，以<strong>最短的字符长度</strong>代表出一个概念。</p>
<p>​        它的信息密度的分母是最小的，信息量与其它词相比却差不多，所以信息密度高到吓人，因而导致其<strong>准确度高到可怕</strong>。</p>
<p>​        而还因为它信息密度如此之高，它受权重影响也大得难以描述，一对小括号就能体感上产生(prompt:1.35)左右的强大效果。</p>
<p>​        想要修手？用✋或其它想要的手势。想要群像？👪屡试不爽。想要烟花背景？🎇驱散一切问题。想要难以被描绘的骷髅头骨？💀出场就是现在。铅笔画风？✏秒了。浮世绘？🎏解决。哪怕是最难凹的海盗船，也只需要一个🏴‍☠️就能展现了！甚至，只需要♿和动态模糊 ( motion blur )的描述，就能即时上演轮椅漂移的戏码。</p>
<p>​        想要解决一切问题？看看有没有 E M O J I 可以表达它。</p>
<p>所以赛博魔法师们可以在这里:</p>
<p>真正的元素法典</p>
<p><a target="_blank" rel="noopener" href="https://www.emojiall.com/zh-hans">https://www.emojiall.com/zh-hans</a></p>
<p>找到 emoji 大全。</p>
<p>老实说，</p>
<p><strong>这比常见到的什么 tag 大全强了不知道多少倍。</strong></p>
<p><strong>算了，这样的魔法世界还是毁灭吧。</strong></p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<h1 id="-17"><a href="#-17" class="headerlink" title=""></a></h1><h1 id="♿-蚌-埠-感-言-♿"><a href="#♿-蚌-埠-感-言-♿" class="headerlink" title="♿ 蚌 埠 感 言 ♿"></a>♿ 蚌 埠 感 言 ♿</h1><p>​        非常感谢各位的观看，但是非常感谢，总之非常感谢。</p>
<p>​        前面忘了，中间忘了，后面忘了。</p>
<p>​        一开始这本魔导书是一位可爱JK的个人经验集，但后来又不知道怎么回事莫名其妙变成了为新人提供从入门到精通的一条路径。又更后来，笔者们仔细想了想，世界之大无奇不有，五花八门的技巧总会迭代，我们何德何能敢说读完这一本就算精通啊？所以就变成了从麻瓜到入门()</p>
<p>​        安装、第一句话、注意事项、技巧补充、公式总结，一切都是那么水到渠成。有许多技术都是随着本魔导书的编写一同被研究而出的，就比如标准顺序公式、分步描绘应用和通用顺序公式。当时笔者还在群内说，通用顺序公式就是入门时期的最强武器了，写完通用顺序公式就结束吧，这个阶段也没什么可写的啦——</p>
<p>​        结果，就在 2022 年 11 月 2 日晚上 20 点左右，笔者为这魔导书编写感言的时候，关于 emoji 的认知出现了。这确确实实是打乱了一切，我们都绷不住了。紧急加章之后，在“啊差不多得了，这个世界还是毁灭了算了吧”这样的想法之下，我们为这本确实不完全科学的魔导书重新写下了另一版感言——也就是你现在正读到的这一版。</p>
<p>​        😅  抱歉，流汗黄豆请不要出现，我们讨厌你。</p>
<p>​        总之，元素同典在这里也算是完结了，感谢所有在编写过程中支持笔者的大家。我们下一本典（也许没有）再见！</p>
<p><img src="https://i0.hdslb.com/bfs/article/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp" alt="img"></p>
<p>本文为我原创</p>
<p>本文禁止转载或摘编</p>
<p><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=AI&from_source=article"> AI </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=%E9%AD%94%E5%AF%BC%E4%B9%A6&from_source=article">魔导书 </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=AI%E7%BB%98%E5%9B%BE&from_source=article">AI绘图 </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=AI%E7%BB%98%E7%94%BB&from_source=article">AI绘画 </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=NovelAI&from_source=article">NovelAI </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=%E5%85%83%E7%B4%A0%E6%B3%95%E5%85%B8&from_source=article">元素法典 </a><a target="_blank" rel="noopener" href="https://search.bilibili.com/article?keyword=%E5%85%83%E7%B4%A0%E5%90%8C%E5%85%B8&from_source=article">元素同典</a></p>
<ul>
<li>​</li>
<li>​</li>
<li>​</li>
<li>​</li>
<li>​</li>
</ul>
<p>投诉或建议</p>
<p>推荐文章</p>
<p>更多精彩内容</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22514105?from=articleDetail">教你画像素画每周分享227期摘要：教你画像素画每周分享，本周全网精选像素画Top10。关键词：教你画，像素画，像素图，马赛克画，8bit，欣赏，素材，学习参考Sean YoungLena pixelsGlitchedPieXelephzXspriterFranekDante PixelsShiranuiMilosちぷしし鸡汤摘录1、说走就走的旅行值得珍惜2、AI时代，最核心的竞争力和技能或许不再是编程，计算，甚至分析能力，而是和大型语言模型的对话能力。完。教你画像素画绘画42100</a><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22426233?from=articleDetail">原创漫画《简明易懂的明日方舟》第一篇——刻俄柏（小刻）结 语 第一次做这种类型的漫画，自己也是很开心激动的！能够把自己喜欢的游戏用自己喜欢的方式表达出来真的很让人高兴！(<em>^▽^</em>） 这个作品也只是整个系列的开始，以后也会把其他干员也这么画出来，各位读者也敬请期待吧~ 还有，不光是干员，敌方单位也会考虑画的（如果有时间）！说不定会画几个自己的或是人的oc干员，有想让自己的oc干员被展现出来的同学可以等以后火起来再私聊哦<del>（当然目前不接这种活，毕竟没火起来嘛</del>） ps：对画风有疑问的同学，我是仿照《简明易懂的scp》的画风画的，当然也看得出画工并不是很出色，以半猫Josie_绘画6266</a><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv22318404?from=articleDetail">PS SAI2 CSP安装包+安装教程分享三联，评论拿走哦AVICII—Tim绘画9754</a></p>
<p>评论</p>
<ul>
<li>全部评论</li>
<li>​</li>
<li>按时间排序</li>
</ul>
<p>966</p>
<p>280</p>
<p>1641</p>
<p>42</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E5%85%83%E7%B4%A0%E5%90%8C%E5%85%B8/" data-id="clg5w6b98000710m91fui4veq" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-用chatgpt重写高等数学书" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E7%94%A8chatgpt%E9%87%8D%E5%86%99%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B9%A6/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.567Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Model: Default<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">简单的程序员项目以下是一些简单的程序员项目，适合初学者或者有一定经验的程序员：计算器：实现基本的加减乘除功能，可以接受用户输入，并返回计算结果。猜数字游戏：程序生成一个随机数，用户通过猜测来猜出这个数字。To-do List 应用程序：创建一个简单的任务列表，用户可以添加、删除和编辑任务。简单的网站或博客：用 HTML、CSS 和 JavaScript 创建一个静态网站或博客。命令行应用程序：创建一个命令行界面的应用程序，可以接受用户输入，执行相应的操作，并输出结果。贪吃蛇游戏：实现一个贪吃蛇游戏，让玩家通过键盘控制蛇移动并吃食物，同时避免碰到自己或者墙壁。图片处理工具：实现一些基本的图像处理功能，例如裁剪、旋转、缩放、滤镜等等。简单的聊天应用程序：创建一个简单的聊天应用程序，可以让用户发送和接收消息。任务计时器：实现一个简单的任务计时器，可以让用户设置一个计时器来跟踪他们的时间，例如 Pomodoro 技术。简单的游戏开发：使用 Unity 或者其他游戏引擎，创建一个简单的游戏，例如平台游戏或者射击游戏。这些项目可以帮助你锻炼编程技能，提高代码能力，同时也可以作为简历中的项目经验，帮助你在职业生涯中更好的发展。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">githubGitHub 是一个基于 Git 版本控制系统的 web 服务，它为开发者提供了协作、代码管理和版本控制等功能，可以托管项目的源代码，同时也支持社交功能，可以在上面找到其他人的项目并加入或贡献代码。以下是一些关于 GitHub 的重要信息和用途：创建账户：用户需要在 GitHub 上创建一个账户，然后就可以开始托管和共享代码了。创建仓库：在 GitHub 上创建一个仓库，可以把自己的代码上传到仓库中，然后就可以与其他人一起协作开发项目。版本控制：GitHub 基于 Git 版本控制系统，可以帮助你跟踪项目的所有变化，查看代码的历史版本，并回滚到之前的版本。协作：GitHub 支持多人协作，可以邀请其他开发者来共同开发一个项目，或者加入其他人的项目。社交功能：GitHub 支持社交功能，可以在上面查找其他人的项目，关注他们并学习他们的代码。问题跟踪：GitHub 还支持问题跟踪功能，可以让用户提交问题并追踪解决过程。静态网站托管：GitHub Pages 可以用于托管静态网站，可以通过 GitHub Pages 来发布自己的博客或者网站。总之，GitHub 是一个非常强大和有用的工具，可以帮助程序员协作开发项目，学习他人的代码，管理和追踪版本控制，发布网站等等。在开发过程中，GitHub 是一个非常有价值的工具，可以提高生产力和效率。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">how to delete repository in github删除 GitHub 上的仓库很简单。请按照以下步骤执行：登录 GitHub 账户并打开要删除的仓库。点击仓库名称下面的 “Settings” 按钮。向下滚动页面，直到找到 “Danger Zone” 部分。在 “Danger Zone” 部分，点击 “Delete this repository” 按钮。输入要删除仓库的名称（大小写敏感）来确认删除，然后点击 “I understand the consequences, delete this repository” 按钮。输入账户密码来确认删除操作。请注意，删除仓库是一个不可逆转的操作，所有仓库中的数据将被永久删除。在删除仓库之前，请确保您已经备份了仓库中的所有数据，并确认您需要删除该仓库。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">mauiMAUI (Multi-platform App UI) 是微软在 .NET 6 中推出的一项新技术，它是一种跨平台的用户界面框架，可以让开发人员使用单一代码库构建应用程序并在多个平台上运行。MAUI 是 Xamarin.Forms 的下一代版本，它扩展了 Xamarin.Forms 的功能，可以更轻松地实现跨平台应用程序的开发。MAUI 支持 Android、iOS、Windows、MacOS 和 Linux 等平台，可以使用 C# 或者 XAML 编写代码，以及使用 Visual Studio、Visual Studio Code 和 JetBrains Rider 等 IDE 进行开发。MAUI 的一些主要特点包括：单一代码库：MAUI 允许开发人员使用单一代码库来构建应用程序，并将其部署到多个平台上。共享组件：MAUI 允许开发人员在多个平台上共享代码，从而提高了开发效率和代码重用率。高性能：MAUI 采用了高性能的渲染引擎，可以提供更流畅的用户体验。开放式：MAUI 是一个开放式的框架，可以使用 .NET 6 中提供的任何功能，例如 Blazor WebAssembly、gRPC 和 ASP.NET Core。原生体验：MAUI 提供了与各个平台原生用户界面交互的 API，以实现更好的用户体验。MAUI 是一个非常有前途和有用的技术，可以帮助开发人员更轻松地构建跨平台应用程序，从而提高开发效率和代码重用率。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com"><Label    Text="Hello, World!"     SemanticProperties.HeadingLevel="Level1"    FontSize="32"    HorizontalOptions="Center" />这是一个 Xamarin.Forms 中的标签（Label）控件示例代码，它显示文本 “Hello, World!”。除此之外，这个标签控件还具有以下属性：语义Properties.标题级别：这个属性定义了标签控件的语义级别，用于帮助无障碍用户更好地访问应用程序。在这个示例中，语义级别为 Level1。FontSize：这个属性定义了标签控件的字体大小。在这个示例中，字体大小为 32。HorizontalOptions：这个属性定义了标签控件在水平方向上的布局方式。在这个示例中，水平方向上的布局方式为居中对齐。通过这些属性的设置，我们可以更好地控制标签控件的外观和行为。在实际开发中，开发人员可以使用更多的属性来控制标签控件的行为，以实现更好的用户体验。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">maui中弹出窗口在 MAUI 中，可以使用弹出窗口（Pop-up）来显示一些附加信息、警告或者询问用户的消息。下面是一个简单的弹出窗口的示例代码：<code>javascriptCopy codevar result = await DisplayAlert(&quot;确认&quot;, &quot;是否保存更改？&quot;, &quot;是&quot;, &quot;否&quot;);if (result)&#123;    // 保存更改&#125;else&#123;    // 放弃更改&#125;</code>在这个示例中，使用了 DisplayAlert 方法来显示一个弹出窗口。这个方法接受三个参数：标题、消息和两个按钮的文本。在这个示例中，弹出窗口的标题为 “确认”，消息为 “是否保存更改？”，按钮文本分别为 “是” 和 “否”。当用户点击弹出窗口中的按钮时，这个方法将返回一个布尔值来指示用户选择的是哪个按钮。如果用户点击了 “是” 按钮，那么代码将保存更改。如果用户点击了 “否” 按钮，那么代码将放弃更改。这只是一个简单的示例，MAUI 还提供了其他的弹出窗口控件和方法，可以帮助开发人员更好地控制和定制弹出窗口的外观和行为，以适应不同的应用程序需求。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数与极限函数和极限是微积分中的两个基本概念。函数是一个映射，它将一个输入值映射到一个输出值。极限是描述函数在某个点处的趋势，它可以用来计算函数的导数、积分、极值等等。在微积分中，我们通常将函数的极限表示为：lim f(x) &#x3D; Lx→a其中，f(x) 是函数，a 是函数的自变量在趋近的值，L 是函数在 a 处的极限值。这个式子表示当自变量 x 趋近于 a 时，函数 f(x) 的值趋近于 L。如果函数 f(x) 在 x &#x3D; a 处连续，则 L 就等于 f(a)。函数的极限有许多应用，例如：计算导数：导数是函数在某个点的斜率，可以使用极限来计算。计算积分：积分是函数在某个区间上的面积，可以使用极限来计算。计算极值：极值是函数在某个区间上的最大值或最小值，可以使用极限来计算。描述函数的行为：函数的极限可以描述函数在某个点处的行为，例如函数的连续性、可导性等等。在学习微积分时，函数和极限是非常重要的概念，可以帮助我们更好地理解和计算函数的各种性质和行为。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">计算积分举例以下是一个计算积分的例子：假设要计算函数 f(x) &#x3D; x^2 在区间 [0, 2] 上的积分。我们可以使用积分的定义来计算：∫(0 to 2) x^2 dx首先，我们将区间 [0, 2] 分成 n 个小区间，并在每个小区间上选择一个点 xi。然后，我们可以使用矩形面积来逼近积分的值。具体地，我们可以将每个小区间的长度表示为 Δx &#x3D; (2 - 0)&#x2F;n &#x3D; 2&#x2F;n，然后选择 xi 作为矩形的高度，矩形的宽度为 Δx。这样，第 i 个小区间的矩形面积就是 xi^2 * Δx。因此，整个区间的面积可以表示为：Area ≈ (Δx * (f(x1) + f(x2) + … + f(xn)))≈ (2&#x2F;n * (f(0 + Δx&#x2F;2) + f(0 + 3Δx&#x2F;2) + … + f(2 - Δx&#x2F;2)))当 n 趋近于无穷大时，逼近的矩形面积就会趋近于积分的实际值。因此，我们可以使用极限来计算积分的值：∫(0 to 2) x^2 dx &#x3D; lim (n→∞) (2&#x2F;n * (f(0 + Δx&#x2F;2) + f(0 + 3Δx&#x2F;2) + … + f(2 - Δx&#x2F;2)))简单化简一下这个式子，可以得到：∫(0 to 2) x^2 dx &#x3D; lim (n→∞) (2&#x2F;n * (1^2&#x2F;2 + 3^2&#x2F;2 + … + (2n - 1)^2&#x2F;2))然后，我们可以使用数学公式来计算这个式子的值。具体地，可以使用求和公式：1^2 + 3^2 + … + (2n - 1)^2 &#x3D; n(2n - 1)(2n + 1)&#x2F;3将这个公式代入上面的式子，可以得到：∫(0 to 2) x^2 dx &#x3D; lim (n→∞) (2&#x2F;n * n(2n - 1)(2n + 1)&#x2F;3)&#x3D; 8&#x2F;3因此，函数 f(x) &#x3D; x^2 在区间 [0, 2] 上的积分是 8&#x2F;3。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">映射与函数在数学中，映射和函数是非常重要的概念。它们可以描述输入和输出之间的关系，并用于解决许多问题。映射（Mapping）是一种从一个集合中的元素到另一个集合中的元素的关系。例如，可以将英文单词映射到它们的汉语翻译上，或者将数字映射到它们的平方上。函数（Function）是一种特殊的映射，它指定了每个输入值都有唯一的输出值。换句话说，函数规定了输入和输出之间的一一对应关系。例如，可以将函数 f(x) 定义为 x 的平方。函数通常用符号表示，例如 f(x) 或者 g(x)，其中 x 是自变量，f(x) 或者 g(x) 是函数值。在函数中，我们还可以使用参数来表示函数中的常量，例如 f(x, a) &#x3D; x + a。函数和映射有许多应用，例如：描述物理规律：函数可以用于描述物理规律和自然现象，例如速度、加速度等等。计算机编程：函数可以用于计算机编程中，帮助程序员组织和管理代码。经济学：函数可以用于描述经济学中的供需曲线、边际效用等等。数据处理：函数可以用于数据处理和分析中，例如数据转换、过滤等等。总之，函数和映射是数学中非常重要的概念，可以用于解决许多问题，并且在各种应用领域中都有广泛的应用。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">数列的极限数列的极限是数学中的一个重要概念，它描述了数列在无限趋近于某个值时的趋势。数列的极限可以用来计算级数、证明数学定理等等。在数学中，数列是一组按照一定规律排列的数。例如，数列 {1, 2, 3, 4, 5, …} 就是从 1 开始每次加 1 得到的数列。数列的极限定义如下：如果对于任意给定的正数 ε，都存在正整数 N，使得当 n &gt; N 时，|an - a| &lt; ε 成立，那么我们称数列 {an} 的极限是 a，记作：lim (n→∞) an &#x3D; a这个式子表示当 n 趋近于无穷大时，数列 {an} 的值趋近于 a。例如，对于数列 {1&#x2F;n}，它的极限为 0，表示当 n 趋近于无穷大时，数列的值趋近于 0。这是因为对于任意正数 ε，只要取 N &#x3D; 1&#x2F;ε，那么当 n &gt; N 时，就有：|1&#x2F;n - 0| &#x3D; 1&#x2F;n &lt; ε因此，数列 {1&#x2F;n} 的极限是 0。数列的极限有许多应用，例如：计算级数：级数是数列的和，可以使用数列的极限来计算级数的收敛性和求和。证明数学定理：数列的极限可以用来证明各种数学定理，例如数列收敛定理、数学归纳法等等。计算导数和积分：导数和积分可以通过极限来定义和计算。总之，数列的极限是数学中非常重要的概念，它可以用来描述数列的趋势和规律，并且在各种应用领域中都有广泛的应用。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">无穷大和无穷小在数学中，无穷大和无穷小是两个重要的概念。它们描述了数值的趋势和数量级，在数学分析、微积分、物理学等领域中有广泛应用。无穷大是指数值趋近于无限大的数。我们可以表示无穷大为 ∞，表示数值越来越大而无限接近于正无穷大。无穷小是指数值趋近于零的数。我们可以表示无穷小为 0，表示数值越来越小而无限接近于零。例如，对于函数 f(x) &#x3D; 1&#x2F;x，当 x 趋近于无穷大时，函数值也趋近于无穷小，因为：lim (x→∞) f(x) &#x3D; lim (x→∞) 1&#x2F;x &#x3D; 0另外，当函数 f(x) 的极限为无穷大时，我们可以表示为：lim (x→a) f(x) &#x3D; ∞这个式子表示当自变量 x 趋近于 a 时，函数值趋近于无穷大。在微积分中，无穷小和无穷大经常用于计算导数和积分。例如，当函数的自变量趋近于某个值时，函数的增量可以表示为一个无穷小，然后通过求导数来计算函数的导数。另外，无穷大和无穷小也用于描述函数在某些点的奇异行为，例如函数的极限、间断点等等。总之，无穷大和无穷小是数学中非常重要的概念，它们可以用于描述数值的趋势和数量级，以及计算导数、积分等数学问题。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">极限运算法则极限运算法则是一组用于计算极限的规则和定理，可以简化极限的计算过程。以下是一些常用的极限运算法则：常数乘法法则：如果 lim (n→∞) an &#x3D; a，那么对于任意常数 c，有 lim (n→∞) (c * an) &#x3D; c * a。和差法则：如果 lim (n→∞) an &#x3D; a 和 lim (n→∞) bn &#x3D; b，那么 lim (n→∞) (an + bn) &#x3D; a + b 和 lim (n→∞) (an - bn) &#x3D; a - b。乘法法则：如果 lim (n→∞) an &#x3D; a 和 lim (n→∞) bn &#x3D; b，那么 lim (n→∞) (an * bn) &#x3D; a * b。商法则：如果 lim (n→∞) an &#x3D; a 和 lim (n→∞) bn &#x3D; b，并且 b 不等于 0，那么 lim (n→∞) (an &#x2F; bn) &#x3D; a &#x2F; b。幂函数法则：如果 lim (n→∞) an &#x3D; a，并且 k 是一个正整数，那么 lim (n→∞) (an)^k &#x3D; a^k。夹逼定理：如果对于所有的 n，有 a(n) &lt;&#x3D; b(n) &lt;&#x3D; c(n)，并且 lim (n→∞) a(n) &#x3D; lim (n→∞) c(n) &#x3D; L，那么 lim (n→∞) b(n) &#x3D; L。以上是一些常用的极限运算法则，它们可以帮助我们更快速、简单地计算极限。当然，在计算极限时，我们还需要注意一些特殊情况和细节，例如无穷大、无穷小、间断点等等。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">极限存在准则极限存在准则是判断一个函数在某个点处是否有极限的一些基本规则和定理。以下是一些常用的极限存在准则：夹逼定理：如果对于所有的 n，有 a(n) &lt;&#x3D; b(n) &lt;&#x3D; c(n)，并且 lim (n→∞) a(n) &#x3D; lim (n→∞) c(n) &#x3D; L，那么 lim (n→∞) b(n) &#x3D; L。单调有界准则：如果函数 f(x) 在某个点 x0 的邻域内单调且有界，那么它在 x0 处存在极限。柯西收敛准则：如果对于任意给定的正数 ε，存在正整数 N，使得当 m,n &gt; N 时，|f(m) - f(n)| &lt; ε 成立，那么函数 f(x) 在某个点处存在极限。极限存在的充分必要条件：如果函数 f(x) 在某个点 x0 的邻域内有定义，并且满足对于任意正数 ε，存在正数 δ，使得当 0 &lt; |x - x0| &lt; δ 时，|f(x) - L| &lt; ε 成立，那么函数 f(x) 在 x0 处存在极限，且极限值为 L。以上是一些常用的极限存在准则，它们可以用来判断一个函数在某个点处是否有极限。当然，在使用这些准则时，我们还需要注意一些特殊情况和细节，例如函数的连续性、间断点等等。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">δ怎么读δ在英语中的发音为 &#x2F;dɛltə&#x2F;，读作“delta”。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">两个重要极限在数学中，有两个非常重要的极限，它们分别是自然对数的底数 e 和圆周率 π。自然对数的底数 e 的极限：e &#x3D; lim (n→∞) (1 + 1&#x2F;n)^n这个极限意味着当 n 趋近于无穷大时，(1 + 1&#x2F;n)^n 的值趋近于一个特定的数 e，约等于 2.71828。自然对数的底数 e 在数学和物理学中有广泛的应用，例如指数函数、微积分、复利计算等等。圆周率 π 的极限：π &#x3D; 2 * (2&#x2F;1) * (2&#x2F;3) * (4&#x2F;3) * (4&#x2F;5) * (6&#x2F;5) * (6&#x2F;7) * …这个极限意味着，将上面的无穷级数求和，可以得到圆周率 π 的值，约等于 3.14159。圆周率 π 在几何学、物理学、工程学等领域中有广泛的应用，例如计算圆的面积和周长、计算圆柱和球体的体积等等。总之，自然对数的底数 e 和圆周率 π 是数学中非常重要的概念，它们在各种应用领域中都有广泛的应用。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">无穷肖的比较无穷小和无穷大是用于描述数值趋势的数学概念，它们常常被用于极限的计算和分析中。在比较无穷小和无穷大时，可以使用以下规则：如果两个无穷小的比值趋近于 1，则这两个无穷小是等价的。例如，当 x 趋近于 0 时，x 和 sin(x)&#x2F;x 的比值趋近于 1，因此 x 和 sin(x)&#x2F;x 是等价的无穷小。如果一个无穷小与一个无穷大相乘，则结果是一个无穷大。例如，当 x 趋近于无穷大时，x * 1&#x2F;x 的值趋近于 1，因此 x * 1&#x2F;x 是一个无穷大。如果一个无穷小与一个有限值相乘，则结果是一个无穷小。例如，当 x 趋近于 0 时，x * 2 的值趋近于 0，因此 x * 2 是一个无穷小。如果一个无穷小的高次幂趋近于无穷小，则这个无穷小是比它的高次幂更小的无穷小。例如，当 x 趋近于 0 时，x^2 和 x^3 的比值趋近于 0，因此 x 是比 x^2 更小的无穷小。总之，比较无穷小和无穷大时，需要考虑它们的数量级、比值和运算等因素。对于特定的问题，可能需要使用不同的比较方法和技巧。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">无穷小在数学中，无穷小是指当自变量趋近于某个值时，函数值趋近于零的量。无穷小可以用来描述函数在某个点的局部行为，例如斜率、曲率、变化率等等。在极限的计算和分析中，无穷小是一个非常重要的概念。无穷小可以分为以下两类：高阶无穷小：<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">无穷小的比较在比较无穷小时，可以使用以下规则：如果两个无穷小的比值趋近于 1，则这两个无穷小是等价的。例如，当 x 趋近于 0 时，x 和 sin(x)&#x2F;x 的比值趋近于 1，因此 x 和 sin(x)&#x2F;x 是等价的无穷小。如果一个无穷小与一个无穷大相乘，则结果是一个无穷大。例如，当 x 趋近于无穷大时，x * 1&#x2F;x 的值趋近于 1，因此 x * 1&#x2F;x 是一个无穷大。如果一个无穷小与一个有限值相乘，则结果是一个无穷小。例如，当 x 趋近于 0 时，x * 2 的值趋近于 0，因此 x * 2 是一个无穷小。如果一个无穷小的高次幂趋近于无穷小，则这个无穷小是比它的高次幂更小的无穷小。例如，当 x 趋近于 0 时，x^2 和 x^3 的比值趋近于 0，因此 x 是比 x^2 更小的无穷小。总之，比较无穷小时，需要考虑它们的数量级、比值和运算等因素。对于特定的问题，可能需要使用不同的比较方法和技巧。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的连续性与间断点在数学中，函数的连续性是一个非常重要的概念，它描述了函数在定义域内的某个点处是否存在间断点。函数在某个点处连续，意味着它在该点处的左右极限存在且相等，即该点处的函数值可以通过极限来求得。具体来说，函数 f(x) 在点 x0 处连续，当且仅当满足以下三个条件：f(x0) 有定义。lim (x→x0) f(x) 存在。lim (x→x0) f(x) &#x3D; f(x0)。如果函数在某个点处不满足上述条件之一，那么这个点就是函数的间断点。函数的间断点可以分为以下几类：可去间断点：如果函数在某个点处的极限存在但与该点处的函数值不相等，则该点为可去间断点。例如，函数 f(x) &#x3D; (x^2 - 1)&#x2F;(x - 1)，在点 x &#x3D; 1 处存在可去间断点。跳跃间断点：如果函数在某个点处的左右极限存在但不相等，则该点为跳跃间断点。例如，函数 f(x) &#x3D; [x]，在整数点处存在跳跃间断点。无穷间断点：如果函数在某个点的左右极限至少一个为无穷大或无穷小，则该点为无穷间断点。例如，函数 f(x) &#x3D; 1&#x2F;x，在 x &#x3D; 0 处存在无穷间断点。总之，函数的连续性和间断点是数学中非常重要的概念，它们可以用来描述函数在某个点处的行为和性质。在函数分析和应用中，需要特别注意函数的连续性和间断点对问题的影响。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">连续函数的运算连续函数的运算法则是指，对于两个连续函数 f(x) 和 g(x)，它们的和、差、积、商等函数仍然是连续函数。具体来说，以下是连续函数的运算法则：和差法则：如果 f(x) 和 g(x) 在某个点 x0 处连续，那么它们的和、差函数 f(x) + g(x) 和 f(x) - g(x) 也在该点处连续。乘法法则：如果 f(x) 和 g(x) 在某个点 x0 处连续，那么它们的乘积函数 f(x) * g(x) 也在该点处连续。商法则：如果 f(x) 和 g(x) 在某个点 x0 处连续，并且 g(x0) 不等于零，那么它们的商函数 f(x) &#x2F; g(x) 也在该点处连续。复合函数法则：如果 f(x) 和 g(x) 分别在某个点 x0 和 y0 处连续，且 f(x0) &#x3D; y0，那么复合函数 h(x) &#x3D; f(g(x)) 也在 x0 处连续。需要注意的是，这些连续函数的运算法则只适用于函数在定义域内的某个点处的连续性。如果函数在定义域内存在间断点，那么需要根据间断点的类型和位置，分别进行讨论和处理。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">反函数的连续在数学中，如果函数 f(x) 在某个区间内是单调递增或单调递减的，并且在该区间内是连续的，那么它在该区间内就是可逆的。这时我们可以定义它的反函数 g(y)，使得对于任意 y 在该区间内，都有 f(g(y))&#x3D;y 和 g(f(x))&#x3D;x 成立。对于一个可逆函数 f(x)，如果它在某个区间内连续，那么它的反函数 g(y) 也在该区间内连续。这是因为连续性的定义是极限的存在性和唯一性，而可逆函数的连续性保证了反函数在极限存在时的唯一性和确定性。具体来说，设函数 f(x) 在区间 I 上连续并且可逆，反函数为 g(y)，如果对于 I 中任意一点 y0，有极限 lim(x→f^(-1)(y0)) f(x)&#x3D;y0，那么 g(y) 在 y0 处连续。这是因为反函数在 y0 处的极限可以表示为 lim(y→y0) f^(-1)(y)，由于 f(x) 的连续性，上式等于 f^(-1)(y0)，即反函数在 y0 处的值，因此反函数在 y0 处连续。总之，反函数的连续性和原函数的连续性密切相关，反函数在原函数连续的区间内也是连续的。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">闭区间上连续函数的性质闭区间上连续函数具有一些重要的性质，这些性质在数学分析和应用中有着广泛的应用。介值定理：如果 f(x) 在闭区间 [a, b] 上连续，且 f(a) 和 f(b) 的符号不同，那么在 (a, b) 内至少存在一个点 c，使得 f(c)&#x3D;0。最大最小值定理：如果 f(x) 在闭区间 [a, b] 上连续，那么它在该区间内必定有最大值和最小值。即存在 c, d∈[a,b]，使得 f(c)≥f(x)≥f(d) 对于所有 x∈[a,b] 成立。一致连续性：如果 f(x) 在闭区间 [a, b] 上连续，那么它在该区间上是一致连续的，即对于任意 ε&gt;0，都存在 δ&gt;0，使得对于任意 x1, x2∈[a, b]，只要 |x1−x2|&lt;δ，就有 |f(x1)−f(x2)|&lt;ε 成立。逐点收敛定理：如果 {f_n(x)} 是闭区间 [a, b] 上的一列连续函数，且在该区间内逐点收敛于函数 f(x)，那么函数 f(x) 也是闭区间 [a, b] 上的连续函数。这些性质都与闭区间上的连续函数的连续性密切相关，而闭区间的有限性质和紧性质也为这些性质的证明提供了重要的基础。在实际问题中，这些性质可以用来刻画函数的行为和性质，对于问题的分析和解决提供了有力的工具。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">导数与微分导数和微分都是微积分中的基本概念，它们描述了函数在某一点处的局部变化率和近似线性变化。导数可以理解为函数在某一点处的斜率，它表示函数在该点处的瞬时变化率。导数的定义是：f’(x) &#x3D; lim(h→0) [f(x+h)-f(x)]&#x2F;h其中，f’(x) 表示函数 f(x) 在点 x 处的导数，h 是自变量 x 的增量。如果该极限存在，则称函数 f(x) 在点 x 处可导，否则不可导。微分可以理解为函数在某一点处的线性近似，它表示函数在该点处的局部变化。微分的定义是：dy &#x3D; f’(x) dx其中，dy 和 dx 分别表示函数在点 (x, y) 处的微小变化量，f’(x) 表示函数在该点处的导数。微分可以用来近似计算函数的值和变化，以及计算一些重要的物理和经济量。导数和微分的关系可以用以下公式表示：dy &#x3D; f’(x) dx即微分等于导数与自变量增量的乘积。这个公式表明，导数可以通过微分来计算，微分可以通过导数来近似计算函数的变化。同时，导数和微分在计算和分析中具有非常重要的应用，例如求函数的最值、判断函数的单调性和凸凹性等等。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的求导法则函数的求导法则是微积分中的基本内容，它描述了如何通过对函数进行运算，求得它的导数。以下是一些常用的函数求导法则：常数法则：对于常数函数 f(x) &#x3D; c，它的导数为 f’(x) &#x3D; 0。幂函数法则：对于幂函数 f(x) &#x3D; x^n，它的导数为 f’(x) &#x3D; n x^(n-1)。指数函数法则：对于指数函数 f(x) &#x3D; a^x，它的导数为 f’(x) &#x3D; a^x * ln(a)。对数函数法则：对于对数函数 f(x) &#x3D; log_a(x)，它的导数为 f’(x) &#x3D; 1&#x2F;(x<em>ln(a))。三角函数法则：对于三角函数 f(x) &#x3D; sin(x)、cos(x)、tan(x) 等，它们的导数为 f’(x) &#x3D; cos(x)、-sin(x)、sec^2(x) 等。反函数法则：对于可逆函数 f(x)，它的反函数 g(y) 的导数为 g’(y) &#x3D; 1&#x2F;f’(g(y))。和、差、积、商的求导法则：对于和、差、积、商等复合函数，它们的导数可以通过对每个函数分别求导后再按照一定规则进行运算得出。需要注意的是，以上的函数求导法则只适用于满足一定条件的函数。在实际问题中，还需要考虑函数的定义域、间断点、极值点等等，以及运用求导法则的技巧和方法。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的求导法则函数的求导法则是微积分中的基本内容，它描述了如何通过对函数进行运算，求得它的导数。以下是一些常用的函数求导法则：常数法则：对于常数函数 f(x) &#x3D; c，它的导数为 f’(x) &#x3D; 0。幂函数法则：对于幂函数 f(x) &#x3D; x^n，它的导数为 f’(x) &#x3D; n x^(n-1)。指数函数法则：对于指数函数 f(x) &#x3D; a^x，它的导数为 f’(x) &#x3D; a^x * ln(a)。对数函数法则：对于对数函数 f(x) &#x3D; log_a(x)，它的导数为 f’(x) &#x3D; 1&#x2F;(x</em>ln(a))。三角函数法则：对于三角函数 f(x) &#x3D; sin(x)、cos(x)、tan(x) 等，它们的导数为 f’(x) &#x3D; cos(x)、-sin(x)、sec^2(x) 等。反函数法则：对于可逆函数 f(x)，它的反函数 g(y) 的导数为 g’(y) &#x3D; 1&#x2F;f’(g(y))。和、差、积、商的求导法则：对于和、差、积、商等复合函数，它们的导数可以通过对每个函数分别求导后再按照一定规则进行运算得出。需要注意的是，以上的函数求导法则只适用于满足一定条件的函数。在实际问题中，还需要考虑函数的定义域、间断点、极值点等等，以及运用求导法则的技巧和方法。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">反函数求导举例对于可逆函数 f(x) 和它的反函数 g(y)，它们之间满足 g(f(x)) &#x3D; x 和 f(g(y)) &#x3D; y。如果要求 g(y) 在某一点 y0 处的导数，可以使用反函数求导法则：g’(y0) &#x3D; 1 &#x2F; f’(x0)其中，x0 &#x3D; g(y0) 为 y0 的原像。具体来说，以下是一个反函数求导的例子：设有函数 f(x) &#x3D; 2x + 3，它的反函数为 g(y) &#x3D; (y - 3) &#x2F; 2，求 g’(4)。首先，我们需要找到 y &#x3D; 4 对应的 x 值，也就是 g(4) &#x3D; (4 - 3) &#x2F; 2 &#x3D; 0.5。因此，x0 &#x3D; 0.5，f’(x) &#x3D; 2，根据反函数求导法则，可得：g’(4) &#x3D; 1 &#x2F; f’(0.5) &#x3D; 1 &#x2F; 2 &#x3D; 0.5因此，g(y) 在 y &#x3D; 4 处的导数为 0.5。需要注意的是，反函数的求导需要注意定义域、可逆性等条件。同时，反函数求导可以通过链式法则和导函数的复合等方法进行推导和求解，具体要根据具体问题进行分析和处理。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">高阶导数高阶导数是指函数的导数的导数，它描述了函数在某一点处的变化率的变化率，是微积分中的重要概念。对于一阶导数 f’(x)，它的导数称为二阶导数，表示函数在该点处的曲率或弯曲程度。二阶导数可以用以下公式表示：f’’(x) &#x3D; [d&#x2F;dx] f’(x)类似地，对于二阶导数 f’’(x)，它的导数称为三阶导数，表示函数在该点处的弯曲程度的变化率。三阶导数可以用以下公式表示：f’’’(x) &#x3D; [d&#x2F;dx] f’’(x)依次类推，对于 n 阶导数 f^(n)(x)，它的导数称为 (n+1) 阶导数，表示函数在该点处的变化率的变化率的变化率。它可以用以下公式表示：f^(n+1)(x) &#x3D; [d&#x2F;dx] f^(n)(x)高阶导数具有一些重要的性质和应用，例如：如果函数 f(x) 的 n 阶导数存在，那么它的 (n+1) 阶导数也存在。如果函数 f(x) 的 n 阶导数在某个点 x0 处存在，那么它在该点的邻域内是连续的。高阶导数可以用来刻画函数的曲率、凸凹性等重要性质。高阶导数在数值计算和优化问题中有广泛的应用，例如牛顿法、梯度下降等等。需要注意的是，高阶导数的计算可以通过递推或直接求导的方式进行，具体要根据问题的复杂程度和精度要求进行选择。同时，高阶导数的计算和分析需要考虑函数的光滑性和连续性等条件，以及导数的性质和运算法则。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">隐函数及由参数方程孙确定的函数导数隐函数是指由方程 F(x,y) &#x3D; 0 所定义的函数 y &#x3D; f(x)，它在某些情况下无法用显式函数的形式表示出来。这种情况下，我们可以通过求解方程 F(x,y) &#x3D; 0 的导数来求解隐函数的导数。具体来说，对于隐函数 y &#x3D; f(x)，它的导数可以用以下公式表示：dy&#x2F;dx &#x3D; -Fx&#x2F;Fy其中，Fx 和 Fy 分别表示方程 F(x,y) &#x3D; 0 对 x 和 y 的偏导数，即：Fx &#x3D; ∂F&#x2F;∂x，Fy &#x3D; ∂F&#x2F;∂y这个公式表明，隐函数的导数可以通过求解方程 F(x,y) &#x3D; 0 的偏导数来求解。需要注意的是，这个公式的适用条件是偏导数存在且不为零，否则就需要用其他方法进行求解。另外，对于由参数方程所确定的函数，它的导数可以用以下公式表示：dy&#x2F;dx &#x3D; dy&#x2F;dt &#x2F; dx&#x2F;dt其中，t 是参数。这个公式表明，如果我们已知函数的参数方程，就可以通过对参数方程求导并运用这个公式来求解函数的导数。需要注意的是，隐函数和由参数方程所确定的函数的导数计算都需要注意函数的光滑性和连续性等条件，以及偏导数和参数的连续性和光滑性等要求。同时，这些方法还可以推广到高阶导数和多元函数的求导中，具体要根据问题的复杂程度和精度要求进行选择。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">举例说明以下是两个例子，说明隐函数和由参数方程所确定的函数的导数的计算方法：隐函数的导数设有方程 x^2 + y^2 - 4 &#x3D; 0，求函数 y &#x3D; f(x) 在点 (1,√3) 处的导数。首先，我们可以对方程两边求导数，得到：2x + 2y * dy&#x2F;dx &#x3D; 0然后，我们可以解出 dy&#x2F;dx：dy&#x2F;dx &#x3D; -x&#x2F;y &#x3D; -1&#x2F;(√3)因此，函数 y &#x3D; f(x) 在点 (1,√3) 处的导数为 -1&#x2F;(√3)。由参数方程所确定的函数的导数设有参数方程 x &#x3D; cos(t)，y &#x3D; sin(t)，求函数 y &#x3D; f(x) 在点 (1&#x2F;2, √3&#x2F;2) 处的导数。首先，我们可以求出参数方程的导数：dx&#x2F;dt &#x3D; -sin(t)，dy&#x2F;dt &#x3D; cos(t)然后，我们可以代入公式：dy&#x2F;dx &#x3D; dy&#x2F;dt &#x2F; dx&#x2F;dt &#x3D; cos(t) &#x2F; (-sin(t)) &#x3D; -cot(t)由于我们要求的点是 (1&#x2F;2, √3&#x2F;2)，满足 x &#x3D; cos(t) &#x3D; 1&#x2F;2 和 y &#x3D; sin(t) &#x3D; √3&#x2F;2。因此，我们可以求得 t &#x3D; π&#x2F;3。代入公式，可得：dy&#x2F;dx &#x3D; -cot(π&#x2F;3) &#x3D; -√3因此，函数 y &#x3D; f(x) 在点 (1&#x2F;2, √3&#x2F;2) 处的导数为 -√3。需要注意的是，以上的例子只是比较简单的情况，实际问题中可能会更加复杂。在求解隐函数和由参数方程所确定的函数的导数时，需要根据具体问题进行分析和处理，以确定正确的方法和计算步骤。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的微分函数的微分是指在某一点处对函数的局部变化进行线性逼近的过程，它是微积分中的一个重要概念。具体来说，对于函数 y &#x3D; f(x) 和它在点 x0 处的微小增量 Δx，函数的微分 df(x0) 可以表示为：df(x0) &#x3D; f’(x0) dx其中，f’(x0) 表示函数 f(x) 在点 x0 处的导数，dx 表示增量 Δx 的微小量。这个式子可以理解为在点 x0 处对函数进行一次线性逼近，把函数的变化量表示为导数和微小增量的乘积。需要注意的是，函数的微分是函数的局部变化的线性逼近，而不是函数的全局变化。因此，函数的微分 df(x0) 只能用来近似表示函数在点 x0 处的变化量，而不能用来计算函数在其他点处的变化量。函数的微分具有一些重要的性质和应用，例如：函数的微分可以用来近似计算函数的变化量和求解一些极值和最优化问题。函数的微分可以用来推导和证明一些微积分中的重要定理和公式。函数的微分可以推广到多元函数的微分中，从而解决多元函数的最优化问题等。需要注意的是，函数的微分和导数之间有着密切的联系，它们是微积分中的两个重要概念。在实际问题中，需要根据具体问题选择使用函数的微分还是导数来描述函数的变化和性质。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">微分中值定理与导数的应用微分中值定理和导数的应用是微积分中的两个重要概念，它们在数学、物理、工程等领域都有广泛的应用。微分中值定理是指对于连续函数 f(x) 和它的导数 f’(x)，存在一个介于 a 和 b 之间的点 c，使得：f(b) - f(a) &#x3D; f’(c) (b - a)其中，a &lt; c &lt; b。这个定理表明了在连续函数上，如果函数在两个点之间的增量与这两个点之间的距离成比例，那么在某个点处一定存在斜率与这个比例相等。微分中值定理可以用来证明一些微积分中的重要结论，例如罗尔定理、拉格朗日中值定理和柯西中值定理等。同时，它还可以用来求解一些最值和极值问题，例如最速下降问题和最优化问题等。导数的应用则更加广泛，它可以用来描述函数在某一点处的变化率，从而研究函数的各种性质。具体来说，导数的应用包括以下几个方面：求解函数的最值和极值问题，例如求解函数的最大值、最小值、拐点、凸凹性等。研究函数的单调性和增减性，例如判断函数在某一区间内是单调递增还是单调递减等。描述函数的图像和性质，例如求解函数的导数、零点、渐近线等。研究函数的变化趋势和速率，例如描述物理过程中的速度、加速度等。导数的应用可以推广到多元函数、偏导数和方向导数等更加复杂的情况中，从而解决更加广泛的数学和物理问题。在实际应用中，导数的应用也需要结合具体问题进行分析和处理，以确定正确的方法和计算步骤。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">洛必达法则洛必达法则（L’Hôpital’s rule）是求解函数极限的一种方法，它适用于在求极限时出现 “0&#x2F;0” 或 “∞&#x2F;∞” 形式的不定型，即分子和分母同时趋于零或无穷大的情况。具体来说，对于函数 f(x) 和 g(x)，如果它们在某个点 a 处连续，且 f(a) &#x3D; g(a) &#x3D; 0 或 ±∞，那么可以将函数 f(x) 和 g(x) 都在该点处求导数，即：lim[x→a] f(x)&#x2F;g(x) &#x3D; lim[x→a] f’(x)&#x2F;g’(x)其中，lim 表示求极限的操作，f’(x) 和 g’(x) 分别表示函数 f(x) 和 g(x) 在点 a 处的导数。需要注意的是，洛必达法则的适用条件是分母的导数 g’(x) 不等于 0。如果分母的导数等于 0，那么就需要使用其他的求极限方法进行处理。洛必达法则的应用范围非常广泛，它可以用于求解各种类型的极限，例如：有理函数的极限，例如 lim[x→∞] (2x^2 + 3x + 1)&#x2F;(x^2 + 2x + 1)指数函数和对数函数的极限，例如 lim[x→0] (e^x - 1)&#x2F;x三角函数和反三角函数的极限，例如 lim[x→0] sin(x)&#x2F;x复合函数的极限，例如 lim[x→0] (e^(sinx) - 1)&#x2F;(x^2)需要注意的是，洛必达法则只是求解函数极限的一种方法，有些情况下也可以使用其他的方法进行求解。同时，在使用洛必达法则求解极限时，还需要注意函数的连续性、光滑性、单调性等性质，以及导数的性质和运算法则等。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">泰勒公式泰勒公式（Taylor’s theorem）是微积分中的一个重要定理，它可以用来将函数在某一点处的局部信息拓展到整个区间上，从而求得函数的近似值和性质。泰勒公式基于多项式的思想，它将函数表示为无限次求导的和，并给出了函数在某一点处的一阶和高阶导数与函数在该点的值之间的关系。泰勒公式的一般形式为：f(x) &#x3D; f(a) + f’(a)(x-a) + (1&#x2F;2!)f’’(a)(x-a)^2 + (1&#x2F;3!)f’’’(a)(x-a)^3 + … + (1&#x2F;n!)f^n(a)(x-a)^n + R_n(x)其中，f(x) 表示要求近似的函数，a 表示要求近似的点，f(a) 表示函数在点 a 处的值，f’(a)、f’’(a)、f’’’(a) 分别表示函数在点 a 处的一阶、二阶、三阶导数，f^n(a) 表示函数在点 a 处的 n 阶导数，(x-a) 表示变量 x 与 a 的差值，R_n(x) 表示余项，即剩余部分。余项 R_n(x) 的具体形式取决于使用泰勒公式的哪种形式和近似精度，它通常表示为一个带有 x 和 a 的函数。根据余项的性质和泰勒公式的特点，我们可以通过限制余项的大小和误差来控制近似精度和误差范围。泰勒公式的应用范围非常广泛，它可以用来求解各种类型的函数近似值和性质，例如：求解函数在某一点处的导数和高阶导数。求解函数在某一点处的极值和拐点。求解函数在某一点处的函数值和导数值。求解函数在某一区间上的近似值和误差范围。需要注意的是，泰勒公式的精度和应用条件取决于具体的函数和问题，需要根据具体情况进行分析和处理。同时，在使用泰勒公式时，还需要注意函数的光滑性、连续性、单调性等性质，以及泰勒公式的收敛性、展开范围和误差估计等问题。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的单调性与曲线的凹凸性函数的单调性和曲线的凹凸性是微积分中的两个重要概念，它们可以用来描述函数的增减和变化趋势，从而研究函数的各种性质和应用。函数的单调性指的是函数在一个区间内的增减性质，如果函数在该区间内单调递增，那么函数的导数在该区间内大于等于 0；如果函数在该区间内单调递减，那么函数的导数在该区间内小于等于 0。函数的单调性可以用来判断函数的最值、拐点、渐近线等性质，同时也可以用来优化一些实际问题，例如求解最大值、最小值等问题。曲线的凹凸性指的是曲线在一个区间内的凹凸性质，如果曲线在该区间内凹向上，那么曲线的二阶导数在该区间内大于等于 0；如果曲线在该区间内凹向下，那么曲线的二阶导数在该区间内小于等于 0。曲线的凹凸性可以用来判断曲线的拐点、最值、最优化等问题，同时也可以用来优化实际问题，例如求解曲线的最大距离、最小面积等问题。需要注意的是，函数的单调性和曲线的凹凸性并不是互相独立的概念，它们之间有着密切的联系和相互作用。具体来说，如果函数在一个区间内单调递增，那么曲线在该区间内也是凹向上的；如果函数在一个区间内单调递减，那么曲线在该区间内也是凹向下的。因此，在研究函数和曲线的性质时，需要将函数的导数和二阶导数的符号和变化趋势考虑在内，综合分析函数和曲线的各种性质和变化趋势。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数的极值与最大值最小值函数的极值是指函数在某一点处取得的局部最值，包括极大值和极小值。最大值和最小值是指函数在某个区间内取得的全局最值，包括最大值和最小值。为了确定函数的极值和最值，我们需要进行以下步骤：求函数的导数，并求出导数为 0 或不存在的点。这些点就是函数的驻点，可能是函数的极值点。对驻点和区间端点进行函数值的比较，找出函数的极值点和最值点。如果一个点的函数值比其它点都大，则该点是函数的最大值点；如果一个点的函数值比其它点都小，则该点是函数的最小值点。需要注意的是，函数的极值点和最值点可能不止一个，且可能存在多个区间，因此在求解时需要对所有可能的情况进行分析和比较。同时，还需要考虑函数的光滑性、连续性、单调性等性质，以及驻点的类型和数量等因素，综合分析函数的各种特点和变化趋势，从而确定函数的极值和最值。在实际应用中，函数的极值和最值常常涉及到各种实际问题，例如求解优化问题、最优化问题、经济学模型、物理模型、工程模型等。因此，函数的极值和最值不仅是数学理论的重要内容，也是实际应用中的重要工具和方法。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">函数图形的描绘要描绘函数的图形，我们需要通过函数的性质和变化趋势来分析函数的特征和形态，从而得出函数的图形。以下是一些常用的方法和技巧：求函数的导数和二阶导数，分析函数的单调性、凹凸性和拐点等特征。导数的正负和变化趋势可以反映函数的单调性，二阶导数的正负和变化趋势可以反映函数的凹凸性和拐点，从而描绘函数的曲线形态。求函数的零点、极值点和最值点，分析函数的特殊点和变化趋势。这些点是函数图形的重要特征，可以帮助我们理解和描绘函数的局部和整体形态。分析函数的对称性和周期性，例如奇偶性、周期性、对称轴等特征。这些特征可以反映函数的规律和对称性，从而描绘函数的图形。利用数学软件和工具，例如绘图软件、计算机代数系统等，绘制函数的图形。这些工具可以帮助我们快速地得到函数的图形，同时也可以通过调整参数和绘制多个图形来比较和分析不同函数的特点和形态。需要注意的是，在描绘函数图形时，我们需要考虑函数的光滑性、连续性、单调性等性质，同时还需要注意误差和精度的影响，从而保证函数图形的准确和可靠。此外，在实际应用中，函数图形的描绘还需要根据具体问题和目的进行分析和处理，以便更好地应用函数图形来解决问题和优化方案。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">曲率曲率（Curvature）是描述曲线弯曲程度的量，它是微积分中的一个重要概念，可以用来分析和描述曲线的性质和特征。曲率是一个标量量，表示曲线上某一点处曲线的弯曲程度，其大小与曲线在该点处的弯曲程度成正比，与曲线的方向无关。曲率的计算公式为：k &#x3D; |T’(s)| &#x2F; |r’(s)|其中，k 表示曲率，s 表示曲线的弧长，T 表示曲线上某一点处的切向量，r 表示曲线的位置向量。公式中的 |T’(s)| 表示切向量的长度，|r’(s)| 表示位置向量的长度。曲率的计算需要对曲线进行求导和求模，比较繁琐。因此，在实际应用中，我们通常采用一些简化的方法和近似公式来计算曲率，例如曲率半径法、切线法、圆心法等。曲率在实际应用中有着广泛的应用，例如在机械设计、物理模型、地图制作、医学成像、图像处理等领域中，曲率都有着重要的应用和意义。曲率可以用来判断曲线的弯曲程度和性质，例如判断曲线的拐点、最小曲率点、最大曲率点等，还可以用来优化曲线的设计和控制，例如优化曲线的路径规划、车辆控制、机器人导航等问题。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">曲率的详细计算过程曲率的计算过程相对复杂，需要对曲线进行求导和求模，以下是具体的计算过程：假设有一条曲线 y&#x3D;f(x)，我们希望计算其在某个点 P(x0,y0) 处的曲率。计算曲线在点 P 处的一阶导数和二阶导数，即 f’(x) 和 f’’(x)，并计算其在点 P 处的值，即 f’(x0) 和 f’’(x0)。计算曲线在点 P 处的切向量 T(x0,y0)，其表示曲线在该点处的切线方向，其方向为沿着曲线变化最快的方向，可以表示为：T(x0,y0) &#x3D; (1, f’(x0))计算曲线在点 P 处的法向量 N(x0,y0)，其表示曲线在该点处的法线方向，其方向为与切向量垂直的方向，可以表示为：N(x0,y0) &#x3D; (-f’(x0), 1)计算曲线在点 P 处的切向量的模长 |T(x0,y0)|，即：|T(x0,y0)| &#x3D; √(1 + [f’(x0)]^2)计算曲线在点 P 处的曲率 k(x0,y0)，即：k(x0,y0) &#x3D; |T’(x0)| &#x2F; |T(x0,y0)|^3其中，T’(x0) 表示切向量的一阶导数，可以表示为：T’(x0) &#x3D; (1, f’’(x0)) &#x2F; √(1 + [f’(x0)]^2) - [1 + f’(x0)] * [f’(x0) * f’’(x0)] &#x2F; [1 + [f’(x0)]^2]^(3&#x2F;2)最终得出曲线在点 P 处的曲率 k(x0,y0)。需要注意的是，上述计算过程中，切向量和法向量的求解需要先求出曲线在该点处的导数，因此需要对曲线进行求导。同时，曲率的计算还需要进行多次求模和复杂的计算，计算量较大，因此在实际应用中，我们通常采用一些简化的方法和近似公式来计算曲率。<img src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2730%27%20height=%2730%27/%3e" alt="img"><img src="https://chat.openai.com/_next/image?url=https://s.gravatar.com/avatar/a751144bf9b6c9907028f985c646aafd?s=480&r=pg&d=https%253A%252F%252Fcdn.auth0.com%252Favatars%252F15.png&w=64&q=75" alt="1525025896@qq.com">方程的近似解方程的近似解指的是对于复杂或难以求解的方程，通过某种方法得到一个接近解析解的数值解。近似解的求解方法有很多，以下是一些常见的方法：数值迭代法：数值迭代法是通过逐步逼近解的方法来求解方程的近似解，其基本思想是从一个初始值开始，不断地进行迭代计算，直到满足一定的条件为止。常见的数值迭代法包括牛顿迭代法、二分法、弦截法等。矩阵方法：矩阵方法是将方程转化为矩阵形式，通过求解矩阵的逆矩阵或解方程组的方法来求解方程的近似解。常见的矩阵方法包括高斯消元法、LU 分解法、雅可比迭代法等。插值法：插值法是通过已知数据点的函数值，通过一定的函数逼近方法来求解函数在某个点处的函数值，从而得到方程的近似解。常见的插值法包括拉格朗日插值法、牛顿插值法等。近似函数法：近似函数法是通过构造某种形式的函数逼近原函数，从而求得方程的近似解。常见的近似函数法包括傅里叶级数法、小波变换法、多项式逼近法等。需要注意的是，方程的近似解通常是通过一定的逼近方法来得到的，因此在实际应用中，需要考虑近似解的误差和精度，以及不同逼近方法的适用范围和优缺点，从而选择合适的方法来求解方程的近似解。同时，还需要结合具体问题和应用场景，对近似解进行分析和比较，以便更好地应用近似解来解决实际问题。Regenerate responseEnglish (US)English (UK)English (AU)普通话 (中国大陆)中文 (台灣)Bahasa IndonesiaČeštinaDanskDeutschEspañol (ES)Español (MX)FrançaisÍslenskaItalianoMagyarNederlandsNorsk bokmålPolskiPortuguês (PT)Português (BR)RomânăSlovenčinaSuomiSvenskaTürkçe日本語한국어Pусский</p>
<p><a href="">New chat</a><a href="">Dark mode</a><a href="">My account</a><a target="_blank" rel="noopener" href="https://help.openai.com/en/collections/3742473-chatgpt">Updates &amp; FAQ</a><a href="">Log out</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E7%94%A8chatgpt%E9%87%8D%E5%86%99%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B9%A6/" data-id="clg5w6b9f000h10m9c52y0t2o" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-以下是一些程序员可以用来练手的程序项目：" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E7%BB%83%E6%89%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.565Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是一些程序员可以用来练手的程序项目：</p>
<ol>
<li>计算器应用程序：编写一个简单的计算器程序，可以进行基本的算术运算，例如加法、减法、乘法和除法。</li>
<li>简单的待办事项列表：编写一个程序，可以记录待办事项列表，并能够添加、编辑和删除列表项。</li>
<li>文件压缩和解压缩工具：编写一个程序，可以压缩和解压缩文件，以减少文件的大小。</li>
<li>图片处理工具：编写一个程序，可以对图片进行一些基本的处理，例如调整大小、旋转和裁剪等。</li>
<li>网络爬虫：编写一个程序，可以从互联网上收集数据，并将它们存储在本地计算机上。</li>
<li>电子邮件客户端：编写一个程序，可以使用电子邮件协议与邮件服务器通信，实现收发邮件的功能。</li>
<li>数据库应用程序：编写一个程序，可以与数据库进行交互，并能够查询、添加、更新和删除数据。</li>
</ol>
<p>这些是一些常见的程序员练手项目，通过实践这些项目，可以帮助程序员巩固编程基础知识，并提高编程技能和经验。</p>
<p>以下是一个Java全栈项目的示例，基于Spring Boot框架和MySQL数据库，实现了一个简单的博客系统：</p>
<ol>
<li>数据库设计</li>
</ol>
<p>博客系统需要存储文章、评论、用户等信息，因此我们需要设计相应的数据库表结构。下面是一份简化的数据库表设计：</p>
<ul>
<li>user：存储用户信息，包括用户名、密码、邮箱等。</li>
<li>post：存储文章信息，包括标题、内容、作者、发布时间等。</li>
<li>comment：存储评论信息，包括评论内容、评论者、评论时间等。</li>
</ul>
<ol>
<li>后端实现</li>
</ol>
<p>我们使用Spring Boot框架实现后端逻辑，包括接口定义、业务逻辑处理和数据库操作等。下面是一些核心代码示例：</p>
<ul>
<li>UserController：用户管理接口定义和实现。</li>
<li>​</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E7%BB%83%E6%89%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A/" data-id="clg5w6b97000510m9f8fe6hcm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线性代数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.563Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p>为了更好地说明施密特正交化方法的应用，我们举一个简单的例子。假设我们有一个向量组$V&#x3D;{\boldsymbol{v}_1,\boldsymbol{v}_2,\boldsymbol{v}_3}$，其中：</p>
<p>$$ \boldsymbol{v}_1 &#x3D; \begin{pmatrix} 1 \ 1 \ 0 \end{pmatrix},\quad \boldsymbol{v}_2 &#x3D; \begin{pmatrix} 1 \ 0 \ 1 \end{pmatrix},\quad \boldsymbol{v}_3 &#x3D; \begin{pmatrix} 0 \ 1 \ 1 \end{pmatrix} $$</p>
<p>我们希望将这个向量组转换为正交向量组。首先，我们选择第一个向量$\boldsymbol{q}_1&#x3D;\boldsymbol{v}_1$，并将它单位化，得到$\boldsymbol{u}_1&#x3D;\frac{\boldsymbol{q}_1}{|\boldsymbol{q}_1|}&#x3D;\frac{1}{\sqrt{2}}\begin{pmatrix} 1 \ 1 \ 0 \end{pmatrix}$。然后，我们计算向量$\boldsymbol{v}_2$在向量$\boldsymbol{q}_1$上的投影向量：</p>
<p>$$ \operatorname{proj}_{\boldsymbol{q}_1}(\boldsymbol{v}_2) &#x3D; \frac{\boldsymbol{v}_2 \cdot \boldsymbol{u}_1}{\boldsymbol{u}_1 \cdot \boldsymbol{u}_1}\boldsymbol{u}_1 &#x3D; \frac{1}{2}\begin{pmatrix} 1 \ 1 \ 0 \end{pmatrix} ​$$</p>
<p>我们将投影向量从向量$\boldsymbol{v}_2$中减去，得到新的向量$\boldsymbol{v}_2^\prime$：</p>
<p>$$ \boldsymbol{v}_2^\prime &#x3D; \boldsymbol{v}<em>2 - \operatorname{proj}</em>{\boldsymbol{q}_1}(\boldsymbol{v}_2) &#x3D; \begin{pmatrix} \frac{1}{2} \ -\frac{1}{2} \ 1 \end{pmatrix} $$</p>
<p>然后，我们选择第二个向量$\boldsymbol{q}_2&#x3D;\boldsymbol{v}_2^\prime$，并将它单位化，得到$\boldsymbol{u}_2&#x3D;\frac{\boldsymbol{q}_2}{|\boldsymbol{q}_2|}&#x3D;\frac{1}{\sqrt{2}}\begin{pmatrix} 1 \ -1 \ 2 \end{pmatrix}$。最后，我们计算向量$\boldsymbol{v}_3$在向量$\boldsymbol{q}_1$和$\boldsymbol{q}_2$张成的空间中的投影向量：</p>
<h2 id="向量内积、长度、正交"><a href="#向量内积、长度、正交" class="headerlink" title="向量内积、长度、正交"></a>向量内积、长度、正交</h2><p>施密特正交化</p>
<p>正交矩阵和正交变换</p>
<p>方阵的特征值和特征向量</p>
<p>相似矩阵</p>
<p>对称矩阵的对角化</p>
<h3 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h3><p>二次型是指一个二次齐次多项式，可以用矩阵的形式来表示。在数学中，二次型通常写作 $Q(\mathbf{x})&#x3D;\mathbf{x}^\top A\mathbf{x}$，其中 $\mathbf{x}$ 是 $n$ 维列向量，$A$ 是一个 $n\times n$ 的实对称矩阵。二次型在矩阵理论、线性代数、微积分和微分方程等数学领域都有广泛的应用。</p>
<p>二次型可以用矩阵的形式来表示，其实是因为二次型有很好的矩阵性质。例如，二次型的矩阵 $A$ 是实对称矩阵，因此有很多好的性质，比如它的特征值都是实数，对应的特征向量可以正交化，而且它可以对角化为对角矩阵。这些性质在矩阵的谱分解和奇异值分解中都有很重要的应用。</p>
<p>二次型在应用中也非常广泛，例如在物理中，二次型可以用来表示系统的能量；在机器学习和模式识别中，二次型可以用来表示样本之间的相似度或距离；在优化中，二次型可以作为目标函数或者约束条件等等。因此，二次型是一种非常重要的数学概念，有着广泛的应用。</p>
<h4 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h4><p>实对称矩阵是指一个方阵 $A$ 满足 $A&#x3D;A^T$，即矩阵 $A$ 的转置等于它本身。因此，实对称矩阵的主对角线上的元素一定是实数，而其余的元素则对称地分布在主对角线两侧。</p>
<p>实对称矩阵具有一些特殊的性质，使得它在很多应用中非常重要。例如，实对称矩阵的特征值一定是实数，而且特征向量可以相互正交，即对于任意两个特征向量 $v_i$ 和 $v_j$，有 $v_i^Tv_j&#x3D;0$。这些性质使得实对称矩阵在线性代数、物理学、工程学等领域都有广泛的应用，例如在矩阵对角化、正交变换、最小二乘法、自然振动等方面。</p>
<h5 id="实对称矩阵的特征向量正交，证明"><a href="#实对称矩阵的特征向量正交，证明" class="headerlink" title="实对称矩阵的特征向量正交，证明"></a>实对称矩阵的特征向量正交，证明</h5><p>$$<br>\begin{bmatrix}1 &amp; 2 &amp; 3\2 &amp; 5 &amp; 6\3 &amp; 6 &amp; 9\\end{bmatrix}<br>$$</p>
<p>设$A$为$n$阶实对称矩阵，$x$和$y$是$A$的两个特征向量，对应的特征值为$\lambda$和$\mu$，即$Ax&#x3D;\lambda x$和$Ay&#x3D;\mu y$。</p>
<p>要证明$x$和$y$正交，即$x\cdot y&#x3D;0$。</p>
<p>由实对称矩阵的性质可知，$A$的转置矩阵等于$A$本身，即$A^T&#x3D;A$。因此，将$x$和$y$的点积展开可得：<br>$$<br>x⋅y&#x3D;(x<br>T<br> ⋅y)<br>T<br> &#x3D;y<br>T<br> ⋅x<br>$$</p>
<p>将$Ax&#x3D;\lambda x$和$Ay&#x3D;\mu y$代入上式可得：</p>
<p>$x⋅y&#x3D;xT⋅y&#x3D;yT⋅x&#x3D;(Ax)T⋅y&#x3D;xT⋅(AT⋅y)&#x3D;xT⋅(A⋅y)&#x3D;xT⋅(μy)&#x3D;μxT⋅y$</p>
<p>同样地，将$x^T\cdot(A\cdot y)$展开可得：</p>
<p>$xT⋅(A⋅y)&#x3D;(xT⋅A)⋅y&#x3D;(Ax)T⋅y&#x3D;(λx)T⋅y&#x3D;λxT⋅y$</p>
<p>将以上结果带入$x\cdot y$的式子中，得到：</p>
<p>$x⋅y&#x3D;μxT⋅y&#x3D;λxT⋅y$</p>
<p>由于$\lambda \neq \mu$，因此$x^T\cdot y&#x3D;0$，即$x\cdot y&#x3D;0$，证毕。因此，实对称矩阵的特征向量正交。</p>
<h5 id="特征向量线性无关"><a href="#特征向量线性无关" class="headerlink" title="特征向量线性无关"></a>特征向量线性无关</h5><p>如果一个矩阵 $A$ 存在 $n$ 个线性无关的特征向量，那么这些特征向量组成的矩阵 $X$ 必定是可逆的。因此，我们可以得到以下结论：</p>
<p>如果 $A$ 是一个对称矩阵，则 $A$ 的所有特征向量是线性无关的。</p>
<p>证明如下：</p>
<p>设 $A$ 的特征向量组成的矩阵为 $X$，即：</p>
<p>��&#x3D;�ΛAX&#x3D;XΛ</p>
<p>其中，$\Lambda$ 为 $A$ 的特征值组成的对角矩阵。</p>
<p>由于 $A$ 是实对称矩阵，则 $A$ 的特征值均为实数。又因为 $A$ 的所有特征向量都是不同的，所以 $\Lambda$ 的对角线上没有重复的特征值。因此，$\Lambda$ 可逆。</p>
<p>由于 $A$ 的所有特征向量是线性无关的，所以 $X$ 是满秩的，即 $X$ 可逆。</p>
<p>因此，我们证明了当 $A$ 是对称矩阵时，$A$ 的所有特征向量是线性无关的。</p>
<h5 id="证明-A-是实对称矩阵，则-A-的特征值均为实数"><a href="#证明-A-是实对称矩阵，则-A-的特征值均为实数" class="headerlink" title="证明$A$ 是实对称矩阵，则 $A$ 的特征值均为实数"></a>证明$A$ 是实对称矩阵，则 $A$ 的特征值均为实数</h5><p>要证明一个实对称矩阵 $A$ 的特征值均为实数，可以采用反证法。假设 $A$ 有一个非实特征值 $\lambda&#x3D;a+bi$，其中 $a$ 和 $b$ 均为实数，$i$ 为虚数单位。</p>
<p>设 $x$ 是 $A$ 对应于 $\lambda$ 的特征向量，则有 $Ax&#x3D;\lambda x$，即：</p>
<p>$Ax&#x3D;(a+bi)x$</p>
<p>令 $y$ 为 $x$ 的共轭复数，即 $y&#x3D;\overline{x}$，则有：</p>
<p>$Ay&#x3D;A\overline{x}&#x3D;\overline{Ax}&#x3D;\overline{(a+bi)x}&#x3D;(a−bi)\overline{x}$</p>
<p>由于 $A$ 是实对称矩阵，有 $A&#x3D;\overline{A^T}&#x3D;A^T$，因此：</p>
<p>$yTAy&#x3D;yTAx&#x3D;(Ay)Tx&#x3D;(λx)Tx&#x3D;λ(xTx)$</p>
<p>又因为 $x\neq 0$，因此 $x^Tx\neq 0$，故有 $y^T Ay&#x3D;\overline{\lambda}(x^Tx)\neq 0$。</p>
<p>另一方面，$y^T Ay&#x3D;y^T A^T y&#x3D;(Ay)^T y&#x3D;(\overline{\lambda}x)^T y&#x3D;\overline{\lambda}(x^Ty)$，由于 $x$ 和 $y$ 为复共轭向量，有 $x^Ty&#x3D;\overline{y^Tx}&#x3D;\overline{x^Ty}$，故 $x^Ty$ 是实数，因此 $y^T Ay&#x3D;\overline{\lambda}(x^Ty)$ 也是实数。</p>
<p>由于 $y^T Ay$ 既是实数又是非零复数，故假设不成立，即 $A$ 的特征值均为实数。</p>
<h3 id="二次型举例"><a href="#二次型举例" class="headerlink" title="二次型举例"></a>二次型举例</h3><p>二次型是指形如 $Q(\boldsymbol{x})&#x3D;\boldsymbol{x}^\top A \boldsymbol{x}$ 的二次多项式函数，其中 $\boldsymbol{x}$ 是 $n$ 维列向量，$A$ 是 $n \times n$ 的实对称矩阵。</p>
<p>以下是一些二次型的例子：</p>
<ol>
<li>$Q(\boldsymbol{x})&#x3D;2x_1^2-3x_2^2+4x_1x_2$，对应的矩阵 $A&#x3D;\begin{bmatrix}2&amp;2\2&amp;-3\end{bmatrix}$。</li>
<li>$Q(\boldsymbol{x})&#x3D;x_1^2+x_2^2+x_3^2$，对应的矩阵 $A&#x3D;\begin{bmatrix}1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{bmatrix}$。</li>
<li>$Q(\boldsymbol{x})&#x3D;3x_1^2-2x_2^2+4x_3^2+2x_1x_2-4x_1x_3+6x_2x_3$，对应的矩阵 $A&#x3D;\begin{bmatrix}3&amp;1&amp;-2\1&amp;-2&amp;3-2&amp;3&amp;4\end{bmatrix}$。</li>
</ol>
<p>注意，同一个二次型可以对应多个不同的矩阵，因为一个矩阵的选择可能依赖于所选择的坐标系。</p>
<h5 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h5><p>对于二次型 $Q(x_1,x_2,\cdots,x_n)&#x3D;\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}a_{ij}x_ix_j$，如果矩阵 $A&#x3D;(a_{ij})$ 为实对称矩阵，则存在一组正交基 ${u_1,u_2,\cdots,u_n}$ 使得 $Q$ 在这组基下的矩阵为对角矩阵，即</p>
<p>$Q(x1,x2,⋯,xn)&#x3D;λ1y12+λ2y22+⋯+λnyn$2</p>
<p>其中 $\lambda_1,\lambda_2,\cdots,\lambda_n$ 为 $Q$ 的 $n$ 个特征值，$y_1,y_2,\cdots,y_n$ 是 $x_1,x_2,\cdots,x_n$ 在正交基 ${u_1,u_2,\cdots,u_n}$ 下的坐标。</p>
<p>这个对角矩阵称为二次型 $Q$ 的标准型。</p>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p>假设有二次型 $q(x_1,x_2,x_3) &#x3D; 2x_1^2 - 4x_1x_2 + 6x_1x_3 + 4x_2^2 - 4x_2x_3 - 2x_3^2$，我们来将其化为标准型。</p>
<p>首先，将二次型的系数矩阵 $A$ 写出来：</p>
<p>�&#x3D;(2−23−24−23−2−2)A&#x3D;⎝⎛2−23−24−23−2−2⎠⎞</p>
<p>然后，我们需要对矩阵 $A$ 进行对角化，得到 $A$ 的特征值和特征向量：</p>
<p>�1&#x3D;6,�2&#x3D;−2,�3&#x3D;2λ1&#x3D;6,λ2&#x3D;−2,λ3&#x3D;2</p>
<p>�1&#x3D;(3−21),�2&#x3D;(−101),�3&#x3D;(111)v1&#x3D;⎝⎛3−21⎠⎞,v2&#x3D;⎝⎛−101⎠⎞,v3&#x3D;⎝⎛111⎠⎞</p>
<p>特征向量需要进行单位化，得到：</p>
<p>�1&#x3D;114(3−21),�2&#x3D;12(−101),�3&#x3D;13(111)u1&#x3D;141⎝⎛3−21⎠⎞,u2&#x3D;21⎝⎛−101⎠⎞,u3&#x3D;31⎝⎛111⎠⎞</p>
<p>构造正交矩阵 $P &#x3D; (\mathbf{u}_1, \mathbf{u}_2, \mathbf{u}_3)$，即：</p>
<p>�&#x3D;(314−1213−2140131141213)P&#x3D;⎝⎛143−142141−21021313131⎠⎞</p>
<p>然后，我们计算 $P^{-1}AP$：</p>
<p>�−1��&#x3D;(6000−20002)P−1AP&#x3D;⎝⎛6000−20002⎠⎞</p>
<p>最终，二次型 $q(x_1,x_2,x_3) &#x3D; 2x_1^2 - 4x_1x_2 + 6x_1x_3 + 4x_2^2 - 4x_2x_3 - 2x_3^2$ 化为标准型：</p>
<p>6�12−2�22+2�326y12−2y22+2y32</p>
<p>其中，$y_1 &#x3D; \mathbf{u</p>
<h5 id="单叶双曲面"><a href="#单叶双曲面" class="headerlink" title="单叶双曲面"></a>单叶双曲面</h5><p>单叶双曲面是三维空间中的一种曲面，它的数学定义为一个旋转双曲线围绕其中心轴旋转所形成的曲面。单叶双曲面可以用以下的方程表示：</p>
<p>$\frac{x^2}{a^2} + \frac{y^2}{b^2} - \frac{z^2}{c^2} &#x3D; 1$</p>
<p>其中 $a,b,c$ 是正实数，且满足 $a^2 + b^2 &lt; c^2$。这个方程也可以写成以下形式：</p>
<p>$\frac{(x - x_0)^2}{a^2} + \frac{(y - y_0)^2}{b^2} - \frac{(z - z_0)^2}{c^2} &#x3D; 1$</p>
<p>其中 $(x_0, y_0, z_0)$ 是单叶双曲面的中心点。这个方程表示的是以 $(x_0, y_0, z_0)$ 为中心，$x$ 轴方向上的轴长为 $2a$，$y$ 轴方向上的轴长为 $2b$，$z$ 轴方向上的轴长为 $2c$ 的单叶双曲面。</p>
<p>单叶双曲面有一个特点，就是它的两个极限曲面都是双曲面。一个极限曲面是以 $z$ 轴为轴心的双曲面，另一个极限曲面是以 $x$ 轴或 $y$ 轴为轴心的双曲面。</p>
<p>Regenerate response</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" data-id="clg5w6b9g000j10m9hg48eehx" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-微信小程序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.562Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><p>微信小程序是一种轻量级的应用程序，可以在微信客户端内运行，无需下载和安装。微信小程序可以快速构建和发布各种类型的应用程序，例如电商、新闻、游戏、社交等，具有体积小、速度快、易用性好等优点。</p>
<p>以下是使用微信小程序开发应用程序的基本步骤：</p>
<ol>
<li>注册小程序账号：在微信公众平台中注册小程序账号，获得小程序的 AppID 和开发者工具。</li>
<li>下载开发者工具：下载微信小程序开发者工具，用于开发、调试和发布小程序。开发者工具可以在官网上下载并安装，支持 Windows、Mac、Linux 等操作系统。</li>
<li>创建小程序项目：在开发者工具中创建一个新的小程序项目，输入小程序的名称和 AppID，并选择项目的类型和目录。</li>
<li>编写代码：使用类似 HTML、CSS 和 JavaScript 的语言编写小程序代码，并通过微信小程序提供的组件和 API 来实现应用程序的功能和交互。</li>
<li>调试和发布：在开发者工具中进行调试和测试，查看小程序的运行效果和问题。完成开发后，可以将小程序发布到微信小程序商店或者其他渠道，供用户下载和使用。</li>
</ol>
<p>需要注意的是，微信小程序开发需要掌握一些基本的前端开发技能，例如 HTML、CSS 和 JavaScript，同时还需要了解微信小程序的组件和 API，以及相关的开发规范和要求。另外，在小程序的设计和开发过程中，还需要考虑用户体验、安全性和性能等方面的问题，以确保小程序的质量和可用性。</p>
<p>小程序举例</p>
<p>微信小程序是一种轻量级的应用程序，可在微信内部使用。以下是一些微信小程序的例子：</p>
<ol>
<li>美团外卖：这是一个可以让用户在线订购外卖的小程序，用户可以选择菜品并进行支付。该小程序与微信支付紧密集成，使得用户可以方便快捷地完成订单。</li>
<li>携程旅行：这是一个提供旅游预订服务的小程序，用户可以在上面查看并预订酒店、机票、景点门票等。该小程序也与微信支付紧密集成，用户可以直接在小程序内完成支付。</li>
<li>微信读书：这是一个在线阅读平台，用户可以在上面购买电子书籍并阅读。该小程序支持在线阅读、离线阅读等功能，并且用户可以在上面进行书签、笔记等操作。</li>
<li>拼多多：这是一个提供便宜商品的小程序，用户可以在上面浏览各种商品，并参与拼团活动。该小程序提供了多种付款方式，包括微信支付、支付宝等。</li>
<li>腾讯视频：这是一个在线视频平台，用户可以在上面观看各种电影、电视剧、综艺节目等。该小程序支持在线观看、离线下载等功能，并且用户可以在上面进行评论、点赞等操作。</li>
</ol>
<p>这些小程序都是为了提供方便的服务而设计的，用户可以通过微信快速地访问它们，并进行相关操作。</p>
<p>$$\hat{\mu}<em>2&#x3D;\frac{1}{n}\sum</em>{i&#x3D;1}^n(X_i-\bar{X})^2$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" data-id="clg5w6b99000810m92161fz0r" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-土地开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E5%9C%9F%E5%9C%B0%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.560Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="土地开发"><a href="#土地开发" class="headerlink" title="土地开发"></a>土地开发</h1><p>中国进行土地开发需要遵循一系列规划、审批和管理的程序。以下是一些建议的关键步骤：</p>
<ol>
<li>确定土地用途：首先，确定土地的具体用途，如住宅、商业、工业或农业用地。</li>
<li>规划设计：根据土地用途，开展详细的规划设计，包括基础设施、交通、绿化等方面的规划。</li>
<li>土地勘察和评估：进行土地勘察和评估，了解土地的地理、地质、水文等条件，以及土地的价值和开发潜力。</li>
<li>办理土地使用权：在中国，土地属于国家所有。企业或个人需要向政府申请土地使用权，一般通过出让、划拨、租赁等方式取得。</li>
<li>环境影响评价：对土地开发项目进行环境影响评价，分析项目对环境的影响，提出相应的环境保护措施。</li>
<li>办理建设用地规划许可：向有关部门提交土地规划设计，并取得建设用地规划许可证。</li>
<li>办理建设工程规划许可：在取得建设用地规划许可证后，进一步提交建筑设计方案，取得建设工程规划许可证。</li>
<li>办理施工许可：在完成前述步骤后，向相关部门申请施工许可证，准备开工建设。</li>
<li>施工与监督：在土地开发过程中，要确保按照规划和设计方案进行施工，并接受政府部门的监督和检查。</li>
<li>竣工验收：项目竣工后，需要通过有关部门的验收，确保项目达到预定标准。</li>
<li>办理房地产权证：对于房地产开发项目，还需要办理房地产权证，以便项目的交付和使用。</li>
</ol>
<p>请注意，这些步骤可能因地区、项目类型和规模而有所不同。具体操作应遵循当地政府的相关法规和政策。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E5%9C%9F%E5%9C%B0%E5%BC%80%E5%8F%91/" data-id="clg5w6b98000610m91os8hgip" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.558Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构（Data Structure）是计算机科学中研究组织和存储数据的一门学科。数据结构可以定义为一组数据元素以及在这些数据元素之间的关系，以及对这些数据元素进行操作的一组方法。通过数据结构，可以更加高效地存储、查找、删除和插入数据。</p>
<p>常见的数据结构包括数组、链表、栈、队列、树、图等。不同的数据结构有着不同的优缺点和适用场景，选择合适的数据结构可以提高程序的运行效率和空间利用率。</p>
<p>数据结构是计算机科学中基础的概念之一，对于软件工程师和计算机科学家而言都非常重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="clg5w6b9b000a10m9fkp0dp68" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-神经网络反向传播" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.556Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>神经网络反向传播</p>
<p>假设女人对男的打分遵循$y&#x3D;x1+x2+6$这样的规律，x1表示钱，x2表示外貌，6表示安慰分，但是我们不知道。所以要建立</p>
<p>神经网络</p>
<p>$y&#x3D;Theta*[X,1]$</p>
<p>第一个男的钱1，外貌1，女生打分8，</p>
<p>初始化$Theta&#x3D;[[0,0,0]]$，所以误差是8</p>
<p>我们要根据8来计算Theta更新幅度，咋算呢</p>
<p>就是要算梯度，$\partial y(Theta)&#x3D;[[1,1,6]]$</p>
<p>所以梯度更新就按这个来，8的误差</p>
<p>假设这个神经网络有一层呢</p>
<p>[x1,x2,1]-Theta		[n1,n2]-Phi		[y]<br>$$<br>Y&#x3D;X\Theta \Phi<br>$$<br>初始化Theta&#x3D;[[1,1],[1,1],[1,1]], Phi&#x3D;[[1],[1]]</p>
<p>[1,1,1]-	[3,3]-	6</p>
<p>Y的误差为2，<br>$$<br>\partial Y&#x2F;\partial \Phi&#x3D;[3,3]<br>$$<br>要是你会咋样修改，$\Phi&#x3D;[[1.3],[1.3]]$</p>
<p>继续看看<br>$$<br>\partial n1&#x2F;\partial \Theta&#x3D;[1,1,1]<br>$$</p>
<p>$$<br>\partial N&#x2F;\partial \Theta&#x3D;[[1,1,1],[1,1,1]]<br>$$</p>
<p>$$<br>\partial Y&#x2F;\partial N&#x3D;[[1],[1]]<br>$$</p>
<p>$$<br>\partial Y&#x2F;\partial \Theta&#x3D;[[1],[1]]*[[1,1,1],[1,1,1]]&#x3D;[2,2,2]<br>$$</p>
<p>$\Theta&#x3D;[[1.6,1.6,1.6]]$</p>
<p>$$<br>\Delta \Phi&#x3D;\partial Y&#x2F;\partial \Phi&#x3D;N<br>$$</p>
<p>$$<br>\Delta \Theta&#x3D;\partial Y&#x2F;\partial \Theta&#x3D;\partial Y&#x2F;\partial N*\partial N&#x2F;\partial \Theta<br>&#x3D;\Phi X<br>$$<br>加入有激活函数呢</p>
<p>重新写下题目，一个女生觉得男生是否合格在于分数有没有10分以上，合格为1，不合格为0，遵循上题的打分规则</p>
<p>[x1,x2,1]-	sigmod	y</p>
<p>y&#x3D;sigmod(X*Theta)</p>
<p>初始化Theta为[[1],[1],[1]]</p>
<p>[1,1,1]-	[3]	sigmod(3)&#x3D;0.9</p>
<p>误差就是0.9</p>
<p>反向传播，<br>$$<br>\partial Y&#x2F;\partial \Theta&#x3D;sigmod导(Theta) X<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" data-id="clg5w6b9e000f10m9dcu7bfv9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-人工智能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T01:50:18.555Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><p>很好，人工智能领域是一个充满挑战和机遇的领域，也是未来的一个重要方向之一。以下是我建议你开始进入人工智能领域的一些途径：</p>
<ol>
<li>学习编程：人工智能需要编程技能，所以你需要学习至少一种编程语言，如Python或者C++。学习编程也需要掌握基本的数据结构和算法。</li>
<li>学习数学和统计学：人工智能需要用到很多数学和统计学知识，如线性代数、微积分、概率论和统计推断等。</li>
<li>学习机器学习和深度学习：机器学习和深度学习是人工智能领域最重要的技术之一，学习这些技术需要理解模型、算法和优化方法等。</li>
<li>参加在线课程：现在有很多在线课程提供了人工智能方面的培训，如Coursera、Udacity、edX等。</li>
<li>参加研究项目：加入一个人工智能研究项目可以帮助你深入了解人工智能技术，提高实践经验，也可以扩展你的社交网络。</li>
<li>参加行业会议和研讨会：参加行业会议和研讨会可以帮助你了解当前人工智能领域的最新趋势和最新技术，也可以扩展你的社交网络。</li>
</ol>
<h2 id="比较入门的研究项目"><a href="#比较入门的研究项目" class="headerlink" title="比较入门的研究项目"></a>比较入门的研究项目</h2><p>有很多入门级的人工智能研究项目可以帮助你掌握人工智能技术，下面是一些可能适合你的研究项目：</p>
<ol>
<li>基于图像识别的研究项目：利用计算机视觉技术，对图像进行分类、识别和分割。你可以使用机器学习算法或深度学习算法，如卷积神经网络 (CNN)，来训练一个图像识别模型。</li>
<li>基于自然语言处理的研究项目：利用自然语言处理技术，对文本进行分类、聚类、情感分析和实体识别等。你可以使用机器学习算法或深度学习算法，如循环神经网络 (RNN) 或长短时记忆网络 (LSTM)，来训练一个自然语言处理模型。</li>
<li>基于强化学习的研究项目：利用强化学习技术，让计算机自动学习如何最优化地执行某项任务，如游戏、机器人控制或金融交易等。你可以使用深度强化学习算法，如深度Q网络 (DQN) 或策略梯度算法 (PG)，来训练一个强化学习模型。</li>
<li>基于生成对抗网络 (GAN) 的研究项目：利用生成对抗网络技术，让计算机生成逼真的图像、音频或视频等。你可以使用深度学习算法，如对抗生成网络 (GAN) 或变分自编码器 (VAE)，来训练一个生成模型。</li>
</ol>
<p>以上这些研究项目都是入门级的人工智能项目，可以帮助你了解不同的人工智能技术，并为你今后更深入的研究奠定基础。在开始项目之前，你需要具备一定的编程、数学和统计学基础。</p>
<h2 id="基于强化学习的研究项目"><a href="#基于强化学习的研究项目" class="headerlink" title="基于强化学习的研究项目"></a>基于强化学习的研究项目</h2><p>基于强化学习的研究项目可以帮助你深入了解强化学习技术，并为你在人工智能领域发展提供良好的基础。以下是一些可能适合你的强化学习研究项目：</p>
<ol>
<li>机器人控制：使用强化学习算法来训练机器人控制器，让机器人完成某项任务，如走路、跑步或搬运物品等。</li>
<li>游戏智能：使用强化学习算法来训练计算机游戏代理人，使其在某个游戏中表现出类似人类的智能，如围棋、星际争霸或街头霸王等。</li>
<li>自适应控制：使用强化学习算法来训练控制器，使其自适应环境变化，如飞行器、机器人或智能家居等。</li>
<li>交通管理：使用强化学习算法来训练交通管理系统，使其在城市交通流量高峰期自适应控制交通信号灯，以优化交通流量。</li>
<li>资源调度：使用强化学习算法来训练资源调度系统，使其在云计算、大数据处理或供应链管理等领域中自适应优化资源分配。</li>
</ol>
<p>以上这些研究项目都需要你具备强化学习的基础知识，如马尔科夫决策过程 (MDP)、策略梯度算法 (PG)、深度Q网络 (DQN) 或蒙特卡罗树搜索 (MCTS) 等。如果你对强化学习还不熟悉，可以先阅读相关的学习资料，如 Sutton 和 Barto 的《强化学习导论》或 David Silver 的强化学习课程，以了解强化学习的基本概念和算法。</p>
<h2 id="使用强化学习算法来训练计算机游戏代理人"><a href="#使用强化学习算法来训练计算机游戏代理人" class="headerlink" title="使用强化学习算法来训练计算机游戏代理人"></a>使用强化学习算法来训练计算机游戏代理人</h2><p>使用强化学习算法来训练计算机游戏代理人是一个非常有趣和具有挑战性的研究项目。以下是一些步骤，可以帮助你开始这个项目：</p>
<ol>
<li>确定游戏：选择一个计算机游戏作为你的研究对象。选择一个比较简单的游戏作为起点，例如 Atarti 游戏中的 Pong 或 Space Invaders。</li>
<li>构建游戏环境：使用编程语言和游戏开发工具，如 Pygame、Unity 或 Unreal Engine，构建游戏环境。游戏环境应该提供游戏状态的观测，以及让代理人能够执行游戏操作的接口。</li>
<li>确定状态和动作：定义游戏的状态和动作。状态是代理人在游戏中观察到的信息，例如游戏画面中的像素值。动作是代理人可以执行的操作，例如移动游戏角色或发射子弹。</li>
<li>设计奖励函数：定义奖励函数，以鼓励代理人执行期望的动作并避免不良的行为。例如，在 Pong 中，奖励函数可以给代理人加分，当它击打球并使对手无法回击时。</li>
<li>选择强化学习算法：选择一个强化学习算法来训练代理人，例如 Q-learning、深度 Q 网络或策略梯度算法等。</li>
<li>训练代理人：使用选定的强化学习算法来训练代理人，使其在游戏环境中学会执行期望的动作，并获得高的奖励。</li>
<li>评估代理人：评估训练好的代理人在游戏中的表现，以了解它的性能和学习效果。</li>
</ol>
<p>这些步骤只是一个基本的框架，具体实现需要根据你的具体情况进行调整和优化。在实现过程中，你可能需要对强化学习算法、深度学习算法、Python 编程、游戏开发等方面有一定的了解。</p>
<h2 id="强化学习导论"><a href="#强化学习导论" class="headerlink" title="强化学习导论"></a>强化学习导论</h2><p>强化学习是一种通过试错来学习最佳决策的机器学习方法。在强化学习中，代理人在环境中不断地进行交互，通过观察环境状态、执行动作以及获得奖励来学习最佳决策策略。下面是一些强化学习的基本概念：</p>
<ol>
<li>状态（State）：代理人所处的环境状态，可以是完全可见的状态，也可以是不完全可见的状态。</li>
<li>动作（Action）：代理人在特定状态下可以执行的操作或者决策。</li>
<li>奖励（Reward）：代理人执行某个动作后，从环境中获得的奖励或惩罚。</li>
<li>策略（Policy）：代理人从环境状态到动作的映射，可以是确定性的，也可以是随机的。</li>
<li>值函数（Value Function）：表示从某个状态出发，按照某种策略进行决策，可以获得的长期累计奖励期望值。</li>
<li>Q 函数（Q-Function）：表示在某个状态下执行某个动作，可以获得的长期累计奖励期望值。</li>
<li>策略评估（Policy Evaluation）：估计在特定策略下的值函数或者 Q 函数。</li>
<li>策略改进（Policy Improvement）：基于当前的值函数或者 Q 函数来改进当前的策略。</li>
<li>策略迭代（Policy Iteration）：交替进行策略评估和策略改进，直到策略收敛。</li>
<li>值迭代（Value Iteration）：在每个状态下迭代计算最优 Q 函数或者值函数，直到值函数收敛。</li>
</ol>
<p>强化学习的应用非常广泛，包括机器人控制、自然语言处理、计算机视觉等领域。强化学习也是 AlphaGo 等人工智能系统的核心技术之一。如果你想深入了解强化学习，可以阅读 Richard Sutton 和 Andrew Barto 合著的《强化学习导论》这本经典的教材，或者参考 David Silver 的强化学习课程。</p>
<h2 id="《强化学习导论》"><a href="#《强化学习导论》" class="headerlink" title="《强化学习导论》"></a>《强化学习导论》</h2><p>《强化学习导论》（Reinforcement Learning: An Introduction）是强化学习领域的经典教材，由 Richard S. Sutton 和 Andrew G. Barto 合著。该书介绍了强化学习的基本概念、算法和应用，并且系统地讲解了强化学习的理论和方法。</p>
<p>《强化学习导论》的内容包括：</p>
<ol>
<li>强化学习概述：介绍了强化学习的基本概念、应用领域和历史发展。</li>
<li>多臂赌博机问题：介绍了强化学习的第一个经典问题——多臂赌博机问题，并且讲解了解决该问题的各种算法。</li>
<li>有模型的强化学习：介绍了强化学习中的基于模型的方法，包括动态规划和蒙特卡罗方法。</li>
<li>无模型的强化学习：介绍了强化学习中的基于值函数和策略的方法，包括时序差分学习和 Q-learning 算法。</li>
<li>强化学习的实践：介绍了如何使用强化学习解决实际问题，包括使用 OpenAI Gym 环境和 TensorFlow 实现强化学习算法。</li>
<li>未来的研究方向：讨论了强化学习在未来的发展方向，包括深度强化学习、多智能体强化学习、强化学习的实践应用等。</li>
</ol>
<p>该书语言简明易懂，深入浅出，适合对强化学习感兴趣的学生、研究者和工程师阅读，也是强化学习领域的经典教材。</p>
<p>假设有一个硬币，我们不知道它正反面出现的概率，现在抛了10次，其中6次出现正面，4次出现反面。现在的问题是，如何用最大似然估计来估计硬币正面出现的概率？</p>
<p>解答过程：</p>
<p>首先，假设正面出现的概率为 $\theta$，则反面出现的概率为 $1-\theta$。</p>
<p>根据似然函数的定义，假设观测数据为 $x&#x3D;(x_1,x_2,…,x_n)$，则似然函数为：</p>
<p>$$L(\theta|x)&#x3D;\theta^6(1-\theta)^4$$</p>
<p>我们需要找到一个使似然函数最大化的参数 $\theta$，即：</p>
<p>$$\hat{\theta}&#x3D;\arg\max_{\theta}L(\theta|x)$$</p>
<p>可以通过求导来找到使似然函数最大化的参数值。对 $L(\theta|x)$ 取对数，得到：</p>
<p>$$\ln L(\theta|x)&#x3D;6\ln\theta+4\ln(1-\theta)$$</p>
<p>对其求导，得到：</p>
<p>$$\frac{\partial}{\partial\theta}\ln L(\theta|x)&#x3D;\frac{6}{\theta}-\frac{4}{1-\theta}$$</p>
<p>令其等于0，解得：</p>
<p>$$\hat{\theta}&#x3D;\frac{6}{10}&#x3D;0.6$$</p>
<p>因此，我们得到的最大似然估计值是 $\hat{\theta}&#x3D;0.6$，即正面出现的概率为 0.6，反面出现的概率为 0.4。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" data-id="clg5w6b97000410m99fcsb24w" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/07/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/07/%E5%85%83%E7%B4%A0%E5%90%8C%E5%85%B8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/07/%E7%94%A8chatgpt%E9%87%8D%E5%86%99%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B9%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/07/%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%BA%9B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E7%BB%83%E6%89%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/07/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>